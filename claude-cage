#!/bin/bash

# Detect operating system
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    else
        echo "unsupported"
    fi
}

OS_TYPE=$(detect_os)

if [ "$OS_TYPE" = "unsupported" ]; then
    echo "Unsupported operating system: $OSTYPE"
    echo "claude-cage supports Linux and macOS only."
    exit 1
fi

# ============================================================================
# OS Abstraction Functions - User Management
# ============================================================================

# Check if user exists
user_exists() {
    local username="$1"
    if [ "$OS_TYPE" = "linux" ]; then
        id -u "$username" >/dev/null 2>&1
    elif [ "$OS_TYPE" = "macos" ]; then
        dscl . -read /Users/"$username" >/dev/null 2>&1
    fi
}

# Get user UID
get_user_uid() {
    local username="$1"
    if [ "$OS_TYPE" = "linux" ]; then
        id -u "$username" 2>/dev/null
    elif [ "$OS_TYPE" = "macos" ]; then
        dscl . -read /Users/"$username" UniqueID 2>/dev/null | awk '{print $2}'
    fi
}

# Get user GID
get_user_gid() {
    local username="$1"
    if [ "$OS_TYPE" = "linux" ]; then
        id -g "$username" 2>/dev/null
    elif [ "$OS_TYPE" = "macos" ]; then
        dscl . -read /Users/"$username" PrimaryGroupID 2>/dev/null | awk '{print $2}'
    fi
}

# Get user home directory
get_user_home() {
    local username="$1"
    if [ "$OS_TYPE" = "linux" ]; then
        getent passwd "$username" 2>/dev/null | cut -d: -f6
    elif [ "$OS_TYPE" = "macos" ]; then
        dscl . -read /Users/"$username" NFSHomeDirectory 2>/dev/null | awk '{print $2}'
    fi
}

# Create user
create_user() {
    local username="$1"
    local user_home="$2"
    local use_custom_home="$3"  # true/false

    if [ "$OS_TYPE" = "linux" ]; then
        if [ "$use_custom_home" = "true" ]; then
            adduser --disabled-password --shell /bin/bash --home "$user_home" --comment "" "$username"
        else
            adduser --disabled-password --shell /bin/bash --comment "" "$username"
        fi
    elif [ "$OS_TYPE" = "macos" ]; then
        # Find next available UID (starting from 501, avoiding system range)
        local max_uid=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
        local new_uid=$((max_uid + 1))
        if [ $new_uid -lt 501 ]; then
            new_uid=501
        fi

        # Find next available GID
        local max_gid=$(dscl . -list /Groups PrimaryGroupID | awk '{print $2}' | sort -n | tail -1)
        local new_gid=$((max_gid + 1))
        if [ $new_gid -lt 501 ]; then
            new_gid=501
        fi

        # Set home directory
        if [ "$use_custom_home" != "true" ]; then
            user_home="/Users/$username"
        fi

        # Create user using dscl
        dscl . -create /Users/"$username"
        dscl . -create /Users/"$username" UserShell /bin/bash
        dscl . -create /Users/"$username" RealName "$username"
        dscl . -create /Users/"$username" UniqueID "$new_uid"
        dscl . -create /Users/"$username" PrimaryGroupID "$new_gid"
        dscl . -create /Users/"$username" NFSHomeDirectory "$user_home"

        # Create home directory if it doesn't exist
        if [ ! -d "$user_home" ]; then
            mkdir -p "$user_home"
            chown "$username:staff" "$user_home"
            chmod 755 "$user_home"
        fi

        # Create group (macOS requires this)
        if ! dscl . -read /Groups/"$username" >/dev/null 2>&1; then
            dscl . -create /Groups/"$username"
            dscl . -create /Groups/"$username" PrimaryGroupID "$new_gid"
        fi
    fi
}

# Delete user
delete_user() {
    local username="$1"

    if [ "$OS_TYPE" = "linux" ]; then
        userdel -r "$username" 2>/dev/null || userdel "$username" 2>/dev/null
    elif [ "$OS_TYPE" = "macos" ]; then
        # Delete user
        dscl . -delete /Users/"$username" 2>/dev/null
        # Delete group if it exists
        dscl . -delete /Groups/"$username" 2>/dev/null
        # Remove home directory if it exists
        local user_home=$(dscl . -read /Users/"$username" NFSHomeDirectory 2>/dev/null | awk '{print $2}')
        if [ -n "$user_home" ] && [ -d "$user_home" ]; then
            rm -rf "$user_home"
        fi
    fi
}

# ============================================================================
# OS Abstraction Functions - Network/Firewall
# ============================================================================

# Check if firewall chain/anchor exists
firewall_chain_exists() {
    local chain_name="$1"

    if [ "$OS_TYPE" = "linux" ]; then
        iptables -L "$chain_name" >/dev/null 2>&1
    elif [ "$OS_TYPE" = "macos" ]; then
        # Check if anchor exists in pf rules
        pfctl -s Anchors 2>/dev/null | grep -q "^$chain_name$"
    fi
}

# Create firewall chain/anchor
create_firewall_chain() {
    local chain_name="$1"
    local user_uid="$2"

    if [ "$OS_TYPE" = "linux" ]; then
        iptables -N "$chain_name" 2>/dev/null || return 1
        # Jump to our chain for output from user
        iptables -I OUTPUT -m owner --uid-owner "$user_uid" -j "$chain_name"
    elif [ "$OS_TYPE" = "macos" ]; then
        # Create anchor in pf
        # macOS pf uses anchors - we'll load rules from a temp file
        local pf_rules_file="/tmp/${chain_name}.pf"

        # Create the anchor definition
        echo "# Claude-cage rules for UID $user_uid" > "$pf_rules_file"
        echo "anchor \"$chain_name\"" >> "$pf_rules_file"

        # Load the anchor (this doesn't activate rules yet, just creates the anchor point)
        pfctl -a "$chain_name" -f "$pf_rules_file" 2>/dev/null || return 1
    fi
}

# Add firewall rule
add_firewall_rule() {
    local chain_name="$1"
    local action="$2"        # ACCEPT or REJECT
    local ip_or_network="$3"
    local ports="$4"          # Optional: comma-separated ports or empty
    local insert_mode="$5"    # Optional: "insert" to add at beginning

    if [ "$OS_TYPE" = "linux" ]; then
        local iptables_action
        if [ "$action" = "ACCEPT" ]; then
            iptables_action="ACCEPT"
        else
            iptables_action="REJECT"
        fi

        local iptables_cmd="iptables -A"
        if [ "$insert_mode" = "insert" ]; then
            iptables_cmd="iptables -I"
        fi

        if [ -z "$ports" ]; then
            # No port restriction - allow/block all ports
            $iptables_cmd "$chain_name" -d "$ip_or_network" -j "$iptables_action"
        else
            # Port restriction - apply to TCP and UDP
            if [[ "$ports" == *","* ]]; then
                # Multiple ports - use multiport
                $iptables_cmd "$chain_name" -p tcp -d "$ip_or_network" -m multiport --dports "$ports" -j "$iptables_action"
                $iptables_cmd "$chain_name" -p udp -d "$ip_or_network" -m multiport --dports "$ports" -j "$iptables_action"
            else
                # Single port
                $iptables_cmd "$chain_name" -p tcp -d "$ip_or_network" --dport "$ports" -j "$iptables_action"
                $iptables_cmd "$chain_name" -p udp -d "$ip_or_network" --dport "$ports" -j "$iptables_action"
            fi
        fi
    elif [ "$OS_TYPE" = "macos" ]; then
        # macOS pfctl - append rules to the anchor's rule file
        local pf_rules_file="/tmp/${chain_name}.pf"
        local pf_action

        if [ "$action" = "ACCEPT" ]; then
            pf_action="pass"
        else
            pf_action="block"
        fi

        if [ -z "$ports" ]; then
            # No port restriction
            echo "$pf_action out to $ip_or_network" >> "$pf_rules_file"
        else
            # With port restriction
            IFS=',' read -ra port_array <<< "$ports"
            for port in "${port_array[@]}"; do
                echo "$pf_action out proto tcp to $ip_or_network port $port" >> "$pf_rules_file"
                echo "$pf_action out proto udp to $ip_or_network port $port" >> "$pf_rules_file"
            done
        fi

        # Reload the anchor with updated rules
        pfctl -a "$chain_name" -f "$pf_rules_file" 2>/dev/null
    fi
}

# Delete firewall chain/anchor
delete_firewall_chain() {
    local chain_name="$1"
    local user_uid="$2"

    if [ "$OS_TYPE" = "linux" ]; then
        # Remove jump rule from OUTPUT chain
        iptables -D OUTPUT -m owner --uid-owner "$user_uid" -j "$chain_name" 2>/dev/null

        # Flush and delete the chain
        iptables -F "$chain_name" 2>/dev/null
        iptables -X "$chain_name" 2>/dev/null
    elif [ "$OS_TYPE" = "macos" ]; then
        # Flush rules from anchor
        pfctl -a "$chain_name" -F all 2>/dev/null

        # Remove the anchor (by clearing its rules, pf will clean it up)
        local pf_rules_file="/tmp/${chain_name}.pf"
        rm -f "$pf_rules_file" 2>/dev/null
    fi
}

# Get last rule number in chain (Linux iptables only)
get_last_firewall_rule_number() {
    local chain_name="$1"

    if [ "$OS_TYPE" = "linux" ]; then
        iptables -L "$chain_name" -n --line-numbers | grep -E "^[0-9]" | tail -1 | awk '{print $1}'
    elif [ "$OS_TYPE" = "macos" ]; then
        # Not applicable to pf
        echo ""
    fi
}

# Delete specific firewall rule by number (Linux iptables only)
delete_firewall_rule_by_number() {
    local chain_name="$1"
    local rule_number="$2"

    if [ "$OS_TYPE" = "linux" ]; then
        iptables -D "$chain_name" "$rule_number" 2>/dev/null
    elif [ "$OS_TYPE" = "macos" ]; then
        # For pf, we rebuild the entire ruleset instead
        # This is handled in add_firewall_rule by rewriting the file
        :
    fi
}

# Add final catch-all rule to chain
add_catchall_firewall_rule() {
    local chain_name="$1"
    local action="$2"  # ACCEPT or REJECT

    if [ "$OS_TYPE" = "linux" ]; then
        iptables -A "$chain_name" -j "$action"
    elif [ "$OS_TYPE" = "macos" ]; then
        local pf_rules_file="/tmp/${chain_name}.pf"
        if [ "$action" = "ACCEPT" ]; then
            echo "pass out" >> "$pf_rules_file"
        else
            echo "block out" >> "$pf_rules_file"
        fi
        pfctl -a "$chain_name" -f "$pf_rules_file" 2>/dev/null
    fi
}

# Important things first
print_banner() {
    local banner=$(cat << 'EOF'



   ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
  ██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
  ██║     ██║     ███████║██║   ██║██║  ██║█████╗
  ██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝
  ╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
   ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝
                  ___________
                .'           '.
               /  -_-    -_-   \
              |    (_)  (_)     |
              |                 |          ,----.
              |      .---.      |         /||||||\
               \    '.__.'     /         | ||||||.|
                '.          .'           | |||||| |
                  '-._____.-'            | |||||| |
                      |||                |_||||||_|
                     /|||\                 \    /
                    / ||| \                 |  |

        ██████╗ █████╗  ██████╗ ███████╗
        ██╔════╝██╔══██╗██╔════╝ ██╔════╝
        ██║     ███████║██║  ███╗█████╗
        ██║     ██╔══██║██║   ██║██╔══╝
        ╚██████╗██║  ██║╚██████╔╝███████╗
         ╚═════╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝


EOF
)

    # ANSI color codes
    local yellow='\033[33m'
    local reset='\033[0m'

    # Print banner line by line with a slight delay for "slide up" effect
    local line_num=0
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        # Lines 4-9 are CLAUDE (after 3 blank lines), lines 23-28 are CAGE
        if (( line_num >= 4 && line_num <= 9 )) || (( line_num >= 23 && line_num <= 28 )); then
            echo -e "${yellow}${line}${reset}"
        else
            echo "$line"
        fi
        sleep 0.01
    done <<< "$banner"
    sleep 0.3
}

# Check if lua is available early (before sudo check)
if ! command -v lua >/dev/null 2>&1; then
    echo "Now listen carefully. We got a problem here."
    echo "I need lua installed on this bird."
    echo "Can't do nothin' without it."
    exit 1
fi

# Check for file monitoring tools (OS-specific)
if [ "$OS_TYPE" = "linux" ]; then
    # Linux uses inotify-tools
    if ! command -v inotifywait >/dev/null 2>&1; then
        echo "Hold on now. We got a problem here."
        echo "Unison needs inotify-tools for file monitoring."
        echo "Without it, this bird ain't gonna watch your files properly."
        echo "Install it: sudo apt install inotify-tools"
        exit 1
    fi
elif [ "$OS_TYPE" = "macos" ]; then
    # macOS - fswatch is optional for unison, we'll fall back to polling
    # Just check that unison itself is available
    if ! command -v unison >/dev/null 2>&1; then
        echo "Hold on now. We got a problem here."
        echo "I need unison installed on this bird."
        echo "Install it: brew install unison"
        exit 1
    fi
fi

# Get the original user (in case running with sudo)
original_user="${SUDO_USER:-$USER}"

# Define config file paths
system_config="/etc/claude-cage/config"
user_config="/home/${original_user}/.config/claude-cage/config"
local_config="claude-cage.config"

# Local config is required
if [ ! -f "$local_config" ]; then
    echo "Hold on now. I'm lookin' for a file called '$local_config' and it ain't here."
    echo "Can't take off without that config file in this directory."
    echo "You understand what I'm tellin' you?"
    exit 1
fi

# Parse command line arguments BEFORE running Lua
# Need to extract non-flag argument to pass to Lua
cli_project_arg=""
for arg in "$@"; do
    if [ "$arg" != "--test" ] && [ "$arg" != "--no-banner" ] && [ "$arg" != "--cleanup" ]; then
        cli_project_arg="$arg"
        break
    fi
done

# Extract config values using Lua with multi-level loading
# Pass command-line project argument to Lua
lua_output=$(lua - "$cli_project_arg" <<EOF 2>&1
-- Get command-line project argument
local cli_arg = arg[1] or ""

-- Function to merge two tables (later overrides earlier)
local function merge_config(base, override)
    local result = {}

    -- Copy base config
    for k, v in pairs(base) do
        result[k] = v
    end

    -- Override with new values
    for k, v in pairs(override) do
        local array_fields = {"excludeName", "excludePath", "excludeRegex", "belowPath", "allowedDomains", "allowedIPs", "allowedNetworks", "blockDomains", "blockIPs", "blockNetworks"}
        local is_array_field = false
        for _, field in ipairs(array_fields) do
            if k == field then
                is_array_field = true
                break
            end
        end

        if is_array_field and type(v) == "table" then
            -- Merge array fields
            result[k] = result[k] or {}
            for _, item in ipairs(v) do
                table.insert(result[k], item)
            end
        else
            -- Override value
            result[k] = v
        end
    end

    return result
end

-- Define a handler for claude_cage function
local configs = {}
function claude_cage(tbl)
    table.insert(configs, tbl)
end

-- Load configs in priority order (system -> user -> local)
local config_files = {
    "$system_config",
    "$user_config",
    "$local_config"
}

for _, path in ipairs(config_files) do
    local f = io.open(path, "r")
    if f then
        f:close()
        local success, err = pcall(function()
            dofile(path)
        end)
        if not success then
            io.stderr:write("Error loading config file: " .. path .. "\n")
            io.stderr:write(tostring(err) .. "\n")
            os.exit(1)
        end
    end
end

-- Merge all configs loaded so far
local config = {}
for _, cfg in ipairs(configs) do
    config = merge_config(config, cfg)
end

-- Determine project name from CLI arg or config
local project = cli_arg ~= "" and cli_arg or config.project or ""

-- If project name is set (from CLI or config), try to load project-specific config
if project ~= "" then
    local project_config = project .. ".claude-cage.config"
    local f = io.open(project_config, "r")
    if f then
        f:close()
        -- Reset configs table to reload just the project config
        local project_configs = {}
        local old_claude_cage = claude_cage
        function claude_cage(tbl)
            table.insert(project_configs, tbl)
        end

        local success, err = pcall(function()
            dofile(project_config)
        end)

        -- Restore original function
        claude_cage = old_claude_cage

        if not success then
            io.stderr:write("Error loading project config file: " .. project_config .. "\n")
            io.stderr:write(tostring(err) .. "\n")
            os.exit(1)
        end

        -- Merge project-specific configs on top of main config
        for _, cfg in ipairs(project_configs) do
            config = merge_config(config, cfg)
        end
    end
end

-- Update project from CLI arg if provided (CLI arg takes precedence)
if cli_arg ~= "" then
    config.project = cli_arg
    project = cli_arg
end

-- Set defaults from config (but don't override project if already set from CLI)
if project == "" then
    project = config.project or ""
end
local user = config.user or "claude"
local userMode = config.userMode or "single"  -- Options: "single" or "per-project"
local userAppend = config.userAppend or ""
local source = config.source or ""
local sync = config.sync or ""
local mountBase = config.mountBase  -- nil if not set, "" if explicitly empty
local mountBaseExplicitlySet = config.mountBase ~= nil
local mounted = config.mounted or ""
local directMount = config.directMount or false
local showBanner = config.showBanner
if showBanner == nil then showBanner = true end

-- If project is set and source is not, use project for source (sync mode only)
-- In direct mount mode (workspace or project), source handling differs
if project ~= "" and source == "" and not directMount then
    source = project
end

-- Determine username based on userMode
if userMode == "single" then
    -- Single-user mode: use base username only
    -- userAppend is ignored
elseif userMode == "per-project" then
    -- Per-project mode: append identifier to username
    if userAppend ~= "" then
        -- Use explicitly set userAppend
        user = user .. "-" .. userAppend
    elseif project ~= "" then
        -- Use project name as default
        user = user .. "-" .. project
    else
        -- No userAppend and no project: use base username (fallback to single-user)
    end
else
    error("Invalid userMode: must be 'single' or 'per-project'")
end

-- If sync is empty, determine from project or source
-- Structure: .caged/project-name/sync
if sync == "" then
    if project ~= "" then
        sync = ".caged/" .. project .. "/sync"
    elseif source ~= "" then
        sync = ".caged/" .. source .. "/sync"
    end
end

-- Set mountBase default (only if not explicitly set in config)
if not mountBaseExplicitlySet then
    mountBase = "caged"
elseif mountBase == nil then
    mountBase = ""
end

-- Set mounted default to project name
if mounted == "" then
    if project ~= "" then
        mounted = project
    else
        mounted = "project"
    end
end

-- Network configuration defaults
local networkMode = config.networkMode or "disabled"

-- Build exclude arguments for unison
local exclude_args = ""

-- excludeName: Ignore files/folders by name anywhere in the tree
if config.excludeName then
    for _, item in ipairs(config.excludeName) do
        exclude_args = exclude_args .. '-ignore "Name ' .. item .. '" '
    end
end

-- excludePath: Ignore exact paths relative to replica root
if config.excludePath then
    for _, item in ipairs(config.excludePath) do
        exclude_args = exclude_args .. '-ignore "Path ' .. item .. '" '
    end
end

-- excludeRegex: Ignore paths matching regex patterns
if config.excludeRegex then
    for _, item in ipairs(config.excludeRegex) do
        exclude_args = exclude_args .. '-ignore "Regex ' .. item .. '" '
    end
end

-- belowPath: Ignore everything below a certain path
if config.belowPath then
    for _, item in ipairs(config.belowPath) do
        exclude_args = exclude_args .. '-ignore "BelowPath ' .. item .. '" '
    end
end

-- Output basic config (use | delimiter to preserve empty fields)
print(user .. "|" .. source .. "|" .. sync .. "|" .. mountBase .. "|" .. mounted .. "|" .. exclude_args .. "|" .. tostring(showBanner))

-- Output exclude patterns for validation (pipe-separated)
local function array_to_string(arr)
    if not arr or #arr == 0 then return "EMPTY" end
    local result = {}
    for _, item in ipairs(arr) do
        table.insert(result, item)
    end
    return table.concat(result, "|")
end

print(array_to_string(config.excludePath))
print(array_to_string(config.excludeName))
print(array_to_string(config.excludeRegex))
print(array_to_string(config.belowPath))

-- Output network configuration
print(networkMode)
print(array_to_string(config.allowedDomains))
print(array_to_string(config.allowedIPs))
print(array_to_string(config.allowedNetworks))
print(array_to_string(config.blockDomains))
print(array_to_string(config.blockIPs))
print(array_to_string(config.blockNetworks))

-- Output project for validation
print(project)

-- Output directMount setting (false, "workspace", or "project")
print(tostring(directMount))
EOF
)
lua_exit_code=$?

# Check if lua command failed BEFORE parsing output
if [ $lua_exit_code -ne 0 ]; then
    echo ""
    echo "============================================"
    echo "Somethin' went wrong with the config files"
    echo "============================================"
    echo ""
    echo "$lua_output"
    echo ""
    echo "Now I want you to fix that and we'll try this again."
    exit 1
fi

# Parse the lua output (only if lua succeeded)
{
    IFS='|' read -r cfg_user cfg_source cfg_sync cfg_mountBase cfg_mounted cfg_exclude cfg_showBanner
    read -r cfg_excludePath
    read -r cfg_excludeName
    read -r cfg_excludeRegex
    read -r cfg_belowPath
    read -r cfg_networkMode
    read -r cfg_allowedDomains
    read -r cfg_allowedIPs
    read -r cfg_allowedNetworks
    read -r cfg_blockDomains
    read -r cfg_blockIPs
    read -r cfg_blockNetworks
    read -r cfg_project
    read -r cfg_directMount
} <<< "$lua_output"

# Replace EMPTY placeholder with empty string for array values
[ "$cfg_excludePath" = "EMPTY" ] && cfg_excludePath=""
[ "$cfg_excludeName" = "EMPTY" ] && cfg_excludeName=""
[ "$cfg_excludeRegex" = "EMPTY" ] && cfg_excludeRegex=""
[ "$cfg_belowPath" = "EMPTY" ] && cfg_belowPath=""
[ "$cfg_allowedDomains" = "EMPTY" ] && cfg_allowedDomains=""
[ "$cfg_allowedIPs" = "EMPTY" ] && cfg_allowedIPs=""
[ "$cfg_allowedNetworks" = "EMPTY" ] && cfg_allowedNetworks=""
[ "$cfg_blockDomains" = "EMPTY" ] && cfg_blockDomains=""
[ "$cfg_blockIPs" = "EMPTY" ] && cfg_blockIPs=""
[ "$cfg_blockNetworks" = "EMPTY" ] && cfg_blockNetworks=""

# Parse command line arguments
test_mode=false
cleanup_mode=false
claude_continue=false
claude_resume=false
source_arg=""
start_subdir=""
project_arg=""

for arg in "$@"; do
    if [ "$arg" = "--test" ]; then
        test_mode=true
    elif [ "$arg" = "--no-banner" ]; then
        cfg_showBanner="false"
    elif [ "$arg" = "--cleanup" ]; then
        cleanup_mode=true
    elif [ "$arg" = "--continue" ]; then
        claude_continue=true
    elif [ "$arg" = "--resume" ]; then
        claude_resume=true
    else
        # Non-flag argument is either project name or subdirectory (depending on mode)
        source_arg="$arg"
    fi
done

# Handle command-line argument based on mode
# The argument was already processed by Lua as either project name or will be used as subdir
if [ -n "$source_arg" ] && [ "$cfg_directMount" = "workspace" -o "$cfg_directMount" = "project" ]; then
    # In directMount mode, argument is the subdirectory/project to work in
    start_subdir="$source_arg"
fi

# In directMount mode, default source to current directory if not set
if [ "$cfg_directMount" = "workspace" -o "$cfg_directMount" = "project" ] && [ -z "$cfg_source" ]; then
    cfg_source="."
fi

# Define cage_home_base early (needed by cleanup mode)
cage_home_base="/home/.claude-cage"

# Validate required config
if [ -z "$cfg_project" ]; then
    echo "Listen to me very carefully now."
    echo "You need to specify a project name either:"
    echo "  1. In the claude-cage.config file: project = \"myproject\""
    echo "  2. On the command line: sudo claude-cage myproject"
    echo "Can't proceed without it."
    exit 1
fi

# Define PID and instance file paths early (needed for cleanup mode)
pid_file=".caged/$cfg_project/claude-cage.pid"
local_instance_file=".caged/$cfg_project/claude-cage.instances"

# For direct mount mode, we track instances by mount point (not project)
# This allows multiple projects under the same mount to share it
# The mount point instance file is stored in the user's home directory
# (will be set after user_home is determined)

if [ -z "$cfg_source" ]; then
    echo "Hold on. Where's the source directory?"
    echo "I need that specified in the config or on the command line."
    exit 1
fi

if [ ! -d "$cfg_source" ]; then
    echo "Now we got a problem. That source directory '$cfg_source' don't exist."
    echo "Can't work with somethin' that ain't there."
    exit 1
fi

# In directMount mode, require a starting subdirectory/project
if [ "$cfg_directMount" = "workspace" ] || [ "$cfg_directMount" = "project" ]; then
    if [ -z "$start_subdir" ]; then
        echo "Hold on now. In direct mount mode, you gotta tell me which project to work in."
        echo "Run it like: sudo claude-cage <subdirectory>"
        echo "For example: sudo claude-cage my-project"
        exit 1
    fi

    # Validate the subdirectory exists
    if [ ! -d "$cfg_source/$start_subdir" ]; then
        echo "Now we got a problem. That subdirectory '$cfg_source/$start_subdir' don't exist."
        echo "Can't start Claude in somethin' that ain't there."
        exit 1
    fi
fi

# Handle cleanup mode
if [ "$cleanup_mode" = true ]; then
    # Now check for root
    if [ "$EUID" -ne 0 ]; then
        echo "Gonna need you to run this as root. Use sudo."
        exit 1
    fi

    echo "=== CLEANUP MODE ==="
    echo "Alright, let's clean up this operation."
    echo ""

    # Get user home directory
    if user_exists "$cfg_user"; then
        # Get home directory using OS abstraction function
        user_home=$(get_user_home "$cfg_user")
    else
        # User doesn't exist, construct expected home path
        if [[ "$cfg_user" == *"-"* ]]; then
            user_home="$cage_home_base/$cfg_user"
        else
            user_home="/home/$cfg_user"
        fi
    fi

    # Construct mount point using same logic as main script
    if [ -n "$cfg_mountBase" ]; then
        mount_point="$user_home/${cfg_mountBase}/${cfg_mounted}"
    else
        mount_point="$user_home/${cfg_mounted}"
    fi

    # Find and unmount any bindfs mounts for this user
    if mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Found mounted directory at $mount_point, unmountin' it now..."
        umount -l "$mount_point" 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "  Unmounted. All clear."
        else
            echo "  Had some trouble unmountin'. May need to clean that up yourself."
        fi
    else
        echo "No mounted directory at $mount_point. Already clean."
    fi

    # Clean up iptables rules for this user
    if user_exists "$cfg_user"; then
        user_uid=$(get_user_uid "$cfg_user")
        # Look for any chains with our pattern
        if [ "$OS_TYPE" = "linux" ]; then
            # First, get all CLAUDE_CAGE chains and their associated UIDs from OUTPUT rules
            iptables -L OUTPUT -n | grep "CLAUDE_CAGE_" | while read -r line; do
                chain=$(echo "$line" | awk '{print $1}')
                uid=$(echo "$line" | grep -o "owner UID match [0-9]*" | awk '{print $4}')

                echo "Found firewall chain: $chain (UID: $uid), cleanin' it up..."

                # Remove the OUTPUT jump rule
                iptables -D OUTPUT -m owner --uid-owner "$uid" -j "$chain" 2>/dev/null

                # Flush and delete the chain
                iptables -F "$chain" 2>/dev/null
                iptables -X "$chain" 2>/dev/null

                echo "  Done. $chain is gone."
            done
        elif [ "$OS_TYPE" = "macos" ]; then
            # Clean up pf anchors
            for anchor in $(pfctl -s Anchors 2>/dev/null | grep "CLAUDE_CAGE_"); do
                echo "Found firewall anchor: $anchor, cleanin' it up..."
                delete_firewall_chain "$anchor" "$user_uid"
                echo "  Done. $anchor is gone."
            done
        fi
    fi

    # Kill processes from PID file
    if [ -f "$pid_file" ]; then
        echo "Found PID file, stoppin' tracked processes..."
        while IFS= read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
                echo "  Process $pid stopped."
            fi
        done < "$pid_file"
        rm -f "$pid_file"
        echo "  PID file's gone."
    else
        echo "No PID file found at $pid_file"
    fi

    # Ask about user deletion (only in per-project mode)
    # In single-user mode, the user is shared across projects and shouldn't be deleted
    if user_exists "$cfg_user"; then
        if [[ "$cfg_user" == *"-"* ]]; then
            # Per-project mode: offer to delete the project-specific user
            echo ""
            echo "User '$cfg_user' exists on this system."
            read -p "Delete user '$cfg_user'? [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "Alright, removin' user '$cfg_user'..."
                delete_user "$cfg_user"
                if [ $? -eq 0 ]; then
                    echo "  Done. User's gone."
                else
                    echo "  Had some trouble removin' the user. May need to clean that up yourself."
                fi
            else
                echo "Leavin' user '$cfg_user' as is."
            fi
        else
            # Single-user mode: don't delete the shared user
            echo ""
            echo "User '$cfg_user' is in single-user mode (shared across projects)."
            echo "Not deletin' the user. If you want to remove it, do that manually."
        fi
    else
        echo "User '$cfg_user' doesn't exist. Nothin' to delete."
    fi

    echo ""
    echo "Cleanup complete. All done."
    exit 0
fi

# Now check for root after validating config
if [ "$EUID" -ne 0 ]; then
    echo "Gonna need you to run this as root. Use sudo."
    exit 1
fi

if [ "$cfg_showBanner" = "true" ]; then
    print_banner
fi

echo "Alright. Here's what we're workin' with:"
echo ""
echo "Configuration:"
echo "  Project:       $cfg_project"
echo "  User:          $cfg_user"
if [ "$cfg_directMount" = "workspace" ]; then
    echo "  Mode:          Direct mount (workspace - access to sibling projects)"
    echo "  Source:        $cfg_source"
    if [ -n "$start_subdir" ]; then
        echo "  Start dir:     $start_subdir"
    fi
elif [ "$cfg_directMount" = "project" ]; then
    echo "  Mode:          Direct mount (project only)"
    echo "  Source:        $cfg_source/$start_subdir"
else
    echo "  Mode:          Sync mode"
    echo "  Source:        $cfg_source"
    echo "  Sync:          $cfg_sync"
fi
if [ -n "$cfg_mountBase" ]; then
    echo "  Mount point:   /home/$cfg_user/$cfg_mountBase/$cfg_mounted"
else
    echo "  Mount point:   /home/$cfg_user/$cfg_mounted"
fi
echo "  Network mode:  $cfg_networkMode"
echo ""
echo "Excludes:"
if [ -n "$cfg_excludePath" ]; then
    IFS='|' read -ra paths <<< "$cfg_excludePath"
    for path in "${paths[@]}"; do
        echo "  Path:          $path"
    done
fi
if [ -n "$cfg_excludeName" ]; then
    IFS='|' read -ra names <<< "$cfg_excludeName"
    for name in "${names[@]}"; do
        echo "  Name:          $name"
    done
fi
if [ -n "$cfg_excludeRegex" ]; then
    IFS='|' read -ra regexes <<< "$cfg_excludeRegex"
    for regex in "${regexes[@]}"; do
        echo "  Regex:         $regex"
    done
fi
if [ -n "$cfg_belowPath" ]; then
    IFS='|' read -ra belows <<< "$cfg_belowPath"
    for below in "${belows[@]}"; do
        echo "  Below path:    $below"
    done
fi
if [ -z "$cfg_excludePath$cfg_excludeName$cfg_excludeRegex$cfg_belowPath" ]; then
    echo "  (none)"
fi
echo ""

# Show active network restrictions if configured
if [ "$cfg_networkMode" != "disabled" ]; then
    echo "Network restrictions ($cfg_networkMode mode):"

    if [ "$cfg_networkMode" = "allowlist" ]; then
        echo "  Allow list (everything else blocked):"
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain in "${domains[@]}"; do
                echo "    Domain:  $domain"
            done
        fi
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip in "${ips[@]}"; do
                echo "    IP:      $ip"
            done
        fi
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network in "${networks[@]}"; do
                echo "    Network: $network"
            done
        fi
    elif [ "$cfg_networkMode" = "blocklist" ]; then
        echo "  Block list (everything else allowed):"
        if [ -n "$cfg_blockDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_blockDomains"
            for domain in "${domains[@]}"; do
                echo "    Domain:  $domain"
            done
        fi
        if [ -n "$cfg_blockIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_blockIPs"
            for ip in "${ips[@]}"; do
                echo "    IP:      $ip"
            done
        fi
        if [ -n "$cfg_blockNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_blockNetworks"
            for network in "${networks[@]}"; do
                echo "    Network: $network"
            done
        fi

        # Show exceptions if any exist
        if [ -n "$cfg_allowedDomains" ] || [ -n "$cfg_allowedIPs" ] || [ -n "$cfg_allowedNetworks" ]; then
            echo "  Exceptions (allowed even when blocked):"
            if [ -n "$cfg_allowedDomains" ]; then
                IFS='|' read -ra domains <<< "$cfg_allowedDomains"
                for domain in "${domains[@]}"; do
                    echo "    Domain:  $domain"
                done
            fi
            if [ -n "$cfg_allowedIPs" ]; then
                IFS='|' read -ra ips <<< "$cfg_allowedIPs"
                for ip in "${ips[@]}"; do
                    echo "    IP:      $ip"
                done
            fi
            if [ -n "$cfg_allowedNetworks" ]; then
                IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
                for network in "${networks[@]}"; do
                    echo "    Network: $network"
                done
            fi
        fi
    fi
    echo ""
fi

# Set computed values
cfg_user="${cfg_user:-claude}"
if [ -z "$cfg_mounted" ]; then
    cfg_mounted="$cfg_source"
fi

# Validate and sanitize username
original_username="$cfg_user"
sanitized_username="$cfg_user"
was_truncated=false

# Check for invalid characters (allowed: lowercase letters, digits, hyphens, underscores)
# Must start with a letter or underscore
if [[ ! "$sanitized_username" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]]; then
    # Replace invalid characters with hyphens
    # First, ensure it starts with a valid character
    if [[ ! "$sanitized_username" =~ ^[a-zA-Z_] ]]; then
        sanitized_username="u-$sanitized_username"
    fi
    # Replace invalid characters with hyphens
    sanitized_username=$(echo "$sanitized_username" | sed 's/[^a-zA-Z0-9_-]/-/g')
    # Convert to lowercase for maximum compatibility
    sanitized_username=$(echo "$sanitized_username" | tr '[:upper:]' '[:lower:]')
fi

# Remove trailing hyphens/underscores (valid but not best practice)
if [[ "$sanitized_username" =~ [-_]+$ ]]; then
    sanitized_username=$(echo "$sanitized_username" | sed 's/[-_]*$//')
fi

# Check username length (useradd has 32 character limit)
if [ ${#sanitized_username} -gt 32 ]; then
    sanitized_username="${sanitized_username:0:32}"
    # Re-check for trailing hyphens after truncation
    sanitized_username=$(echo "$sanitized_username" | sed 's/[-_]*$//')
    was_truncated=true
fi

# Display warning only if username was truncated
if [ "$was_truncated" = true ]; then
    echo ""
    echo "Hold on now. That username's too long for this bird."
    echo "What you wanted:  $original_username (${#original_username} characters)"
    echo "What you got:     $sanitized_username (${#sanitized_username} characters)"
    echo "Had to trim it down. Regulations, you understand."
    echo ""
fi

cfg_user="$sanitized_username"

# Check if sanitized username conflicts with existing system user
if [ "$original_username" != "$sanitized_username" ] && user_exists "$sanitized_username"; then
    echo ""
    echo "Hold on now. We got ourselves a situation here."
    echo "After cleanin' up that username, it became '$sanitized_username'"
    echo "But there's already a user with that name on this system."
    echo ""
    echo "You got two choices:"
    echo "  1. Change the username in your config to somethin' else"
    echo "  2. Continue if you're sure this is the right user to use"
    echo ""
    read -p "Continue with existing user '$sanitized_username'? [y/N] " -n 1 -r
    echo
    if ! [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Smart move. Change that username and try again."
        exit 1
    fi
fi

# Track if user exists before we start
user_existed_before=false
if user_exists "$cfg_user"; then
    user_existed_before=true
fi

# Create claude-cage base directory for tracking/config
mkdir -p "$cage_home_base"

# Track whether we prompted the user to continue
user_was_prompted=false

# Create user if it doesn't exist
if ! user_exists "$cfg_user"; then
    echo "That user '$cfg_user' ain't on this system yet."
    read -p "Want me to create that user? [y/N] " -n 1 -r
    echo
    user_was_prompted=true
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # In single-user mode, use default home directory location
        # In multi-project mode, use /home/claude-cage/<user>
        if [[ "$cfg_user" == *"-"* ]]; then
            # Multi-project mode: home under /home/claude-cage
            user_home="$cage_home_base/$cfg_user"
            create_user "$cfg_user" "$user_home" "true"
            echo "Done. User '$cfg_user' is ready to go (home: $user_home)."
        else
            # Single-user mode: default home directory
            create_user "$cfg_user" "" "false"
            # Get home directory using OS abstraction function
            user_home=$(get_user_home "$cfg_user")
            echo "Done. User '$cfg_user' is ready to go (home: $user_home)."
        fi
        echo "This user's temporary. Gone when we're done here."
    else
        echo "Can't fly this bird without that user. We're done here."
        exit 1
    fi
fi

# Prompt to continue if user wasn't already prompted during user creation
if [ "$user_was_prompted" = "false" ]; then
    echo ""
    read -p "Ready to proceed? [Y/n] " -n 1 -r key
    echo
    if [[ $key =~ ^[Nn]$ ]]; then
        echo "Alright, abortin' the mission."
        exit 0
    fi
fi

# Set user_home for later use
# Get home directory using OS abstraction function
user_home=$(get_user_home "$cfg_user")

# Get user UID for cleanup function (needed for firewall rule deletion)
user_uid=$(get_user_uid "$cfg_user")

# Check if Claude Code is installed for the user
check_claude_installed() {
    local username="$1"
    local home_dir="$2"

    # Check if claude is in user's PATH (including ~/.local/bin)
    if su - "$username" -c "command -v claude" >/dev/null 2>&1; then
        return 0
    fi

    # Also check common locations explicitly
    if [ -x "$home_dir/.local/bin/claude" ]; then
        return 0
    fi

    return 1
}

install_claude_code() {
    local username="$1"
    local home_dir="$2"

    echo ""
    echo "Now hold on. Claude Code ain't installed for user '$username'."
    echo "Can't run this operation without the main man himself."
    echo ""
    read -p "Want me to install Claude Code for this user? [y/N] " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Alright, we're bailin' out. Install Claude Code yourself and try again."
        echo "Run this as the user: curl -fsSL https://claude.ai/install.sh | bash"
        return 1
    fi

    # Check for curl
    if ! command -v curl >/dev/null 2>&1; then
        echo "Now we got a problem. Need curl to download, and it ain't here."
        echo "Install curl and try again, or install Claude Code manually."
        return 1
    fi

    echo "Alright, runnin' the official installer..."
    echo "This might take a minute. Sit tight."

    # Run the official Claude Code installer as the target user
    if su - "$username" -c "curl -fsSL https://claude.ai/install.sh | bash" 2>&1; then
        echo ""
        echo "Done. Claude Code is locked and loaded."
        return 0
    else
        echo ""
        echo "The installer hit a snag. You might need to install manually."
        echo "Try runnin' as the user: curl -fsSL https://claude.ai/install.sh | bash"
        return 1
    fi
}

# Check if Claude Code is available for the user
if ! check_claude_installed "$cfg_user" "$user_home"; then
    if ! install_claude_code "$cfg_user" "$user_home"; then
        echo "Can't proceed without Claude Code installed. We're done here."
        exit 1
    fi
fi

# Construct mount point: /home/<user>/<mountBase>/<mounted>/ or /home/<user>/<mounted>/
# In workspace mode, use source directory basename or "workspace" if source is "."
# In project mode, use the project/subdirectory name
if [ "$cfg_directMount" = "workspace" ]; then
    # Workspace mode: mounted name based on source directory
    if [ "$cfg_source" = "." ]; then
        workspace_name=$(basename "$(pwd)")
    else
        workspace_name=$(basename "$cfg_source")
    fi
    if [ -n "$cfg_mountBase" ]; then
        mount_point="$user_home/${cfg_mountBase}/${workspace_name}"
    else
        mount_point="$user_home/${workspace_name}"
    fi
elif [ "$cfg_directMount" = "project" ]; then
    # Project mode: mounted name is the project subdirectory
    if [ -n "$cfg_mountBase" ]; then
        mount_point="$user_home/${cfg_mountBase}/${start_subdir}"
    else
        mount_point="$user_home/${start_subdir}"
    fi
else
    # Sync mode: use configured mounted name
    if [ -n "$cfg_mountBase" ]; then
        mount_point="$user_home/${cfg_mountBase}/${cfg_mounted}"
    else
        mount_point="$user_home/${cfg_mounted}"
    fi
fi

# For workspace direct mount mode, track instances by mount point instead of project
# This allows multiple subdirectories under the same mount to share it
if [ "$cfg_directMount" = "workspace" ]; then
    # Create a safe filename from mount point path
    mount_point_hash=$(echo "$mount_point" | md5sum | cut -d' ' -f1)
    mount_instance_file="$user_home/.claude-cage-mount-$mount_point_hash"
else
    mount_instance_file=""
fi

# Track iptables chain name for cleanup
# In single-user mode, use a shared chain name; otherwise use per-process chain
if [[ "$cfg_user" == *"-"* ]]; then
    # Multi-project mode: per-process chain
    iptables_chain="CLAUDE_CAGE_$$"
else
    # Single-user mode: shared chain for the user
    iptables_chain="CLAUDE_CAGE_${cfg_user}"
fi

# Global instance file (tracks all projects for this user in single-user mode)
if [[ "$cfg_user" == *"-"* ]]; then
    # Per-project mode: only use local instance file
    global_instance_file=""
else
    # Single-user mode: track instances globally in user's home
    global_instance_file="$user_home/.claude-cage-instances"
fi

# This instance's ID
instance_id="$$"

cleanup() {
    echo ""
    echo "Alright, shuttin' down operations..."

    # For workspace direct mount mode, track by mount point instead of project
    # This ensures we only unmount when the last instance using that mount exits
    should_unmount=true

    if [ "$cfg_directMount" = "workspace" ] && [ -n "$mount_instance_file" ] && [ -f "$mount_instance_file" ]; then
        # Remove this instance from mount point tracker
        sed -i "/^$instance_id$/d" "$mount_instance_file"

        # Check if other instances are still using this mount point
        remaining_mount=()
        while IFS= read -r inst_id; do
            if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                remaining_mount+=("$inst_id")
            fi
        done < "$mount_instance_file"

        if [ ${#remaining_mount[@]} -gt 0 ]; then
            echo "Other instances still usin' mount point (${remaining_mount[*]}). Leavin' it mounted."
            # Update instance file to remove dead instances
            printf "%s\n" "${remaining_mount[@]}" > "$mount_instance_file"
            should_unmount=false
        else
            # Last instance using this mount, clean up the instance file
            rm -f "$mount_instance_file"
        fi
    fi

    # Remove this instance from the local instance file (project tracking)
    if [ -f "$local_instance_file" ]; then
        sed -i "/^$instance_id$/d" "$local_instance_file"

        # Check if there are other instances of THIS project still running
        remaining_local=()
        while IFS= read -r inst_id; do
            if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                remaining_local+=("$inst_id")
            fi
        done < "$local_instance_file"

        if [ ${#remaining_local[@]} -gt 0 ]; then
            echo "Other instances of this project still runnin' (${remaining_local[*]}). Leavin' processes alone."
            # Update local instance file to remove dead instances
            printf "%s\n" "${remaining_local[@]}" > "$local_instance_file"

            # Still need to remove from global in single-user mode
            if [ -n "$global_instance_file" ] && [ -f "$global_instance_file" ]; then
                sed -i "/^$instance_id$/d" "$global_instance_file"
            fi

            echo "This session's done. Stay safe out there."
            return
        else
            # No more instances of this project, remove the local instance file
            rm -f "$local_instance_file"
        fi
    fi

    # Remove from global instance file (single-user mode)
    if [ -n "$global_instance_file" ] && [ -f "$global_instance_file" ]; then
        sed -i "/^$instance_id$/d" "$global_instance_file"

        # Check if there are other projects still running as this user
        remaining_global=()
        while IFS= read -r inst_id; do
            if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                remaining_global+=("$inst_id")
            fi
        done < "$global_instance_file" 2>/dev/null

        if [ ${#remaining_global[@]} -gt 0 ]; then
            echo "Other projects still runnin' as user $cfg_user (${remaining_global[*]})."
            echo "Cleanin' up this project only. User and network rules stay in place."
            # Update global instance file to remove dead instances
            printf "%s\n" "${remaining_global[@]}" > "$global_instance_file"

            # Clean up local processes and mount (only if we should unmount)
            if [ -f "$pid_file" ]; then
                echo "Stoppin' processes from $pid_file..."
                while IFS= read -r pid; do
                    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                        kill "$pid" 2>/dev/null
                    fi
                done < "$pid_file"
                rm -f "$pid_file"
            fi

            if [ "$should_unmount" = "true" ] && mountpoint -q "$mount_point" 2>/dev/null; then
                echo "Unmountin' $mount_point..."
                umount -l "$mount_point" 2>/dev/null
            fi

            echo "This project's done. Other projects still flyin'. Stay safe out there."
            return
        else
            # No more instances for this user, remove the global instance file
            rm -f "$global_instance_file"
        fi
    fi

    # Only run full cleanup if this is the last instance
    echo "Last instance shuttin' down. Cleanin' up everything..."

    # Kill processes from PID file
    if [ -f "$pid_file" ]; then
        echo "Stoppin' processes from $pid_file..."
        while IFS= read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
            fi
        done < "$pid_file"
        rm -f "$pid_file"
    fi

    # Unmount the bindfs mount (only if we should)
    if [ "$should_unmount" = "true" ] && mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Unmountin' $mount_point..."
        umount -l "$mount_point" 2>/dev/null
    fi

    # Clean up firewall rules
    if [[ "$cfg_user" == *"-"* ]]; then
        # Multi-project mode: always clean up per-process chain
        if firewall_chain_exists "$iptables_chain"; then
            echo "Cleanin' up network restrictions..."
            delete_firewall_chain "$iptables_chain" "$user_uid"
        fi
    else
        # Single-user mode: only clean up if no other instances exist
        # Check the global instance file
        has_other_instances=false
        if [ -n "$global_instance_file" ] && [ -f "$global_instance_file" ]; then
            # Check if there are any live instances in the global file
            while IFS= read -r inst_id; do
                if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                    has_other_instances=true
                    break
                fi
            done < "$global_instance_file"
        fi

        if [ "$has_other_instances" = "false" ] && firewall_chain_exists "$iptables_chain"; then
            echo "Last instance for user $cfg_user, cleanin' up network restrictions..."
            delete_firewall_chain "$iptables_chain" "$user_uid"
        fi
    fi

    # Delete user if it didn't exist before AND we're in per-project mode
    # In single-user mode, keep the user around (it's shared across projects)
    if [ "$user_existed_before" = "false" ] && [[ "$cfg_user" == *"-"* ]]; then
        if user_exists "$cfg_user"; then
            echo "User '$cfg_user' is temporary, removin' it now..."
            delete_user "$cfg_user"
        fi
    fi

    echo "All done. Stay safe out there."
}
trap cleanup SIGINT SIGTERM EXIT

# Function to resolve domain to IPs
resolve_domain() {
    local domain="$1"
    # Use getent to resolve domain (supports /etc/hosts and DNS)
    getent ahosts "$domain" 2>/dev/null | awk '{print $1}' | sort -u
}

# Function to parse IP/domain:port specification
# Returns: ip, ports (comma-separated)
parse_ip_port() {
    local spec="$1"
    local ip=""
    local ports=""

    if [[ "$spec" =~ ^(.+):([0-9,]+)$ ]]; then
        ip="${BASH_REMATCH[1]}"
        ports="${BASH_REMATCH[2]}"
    else
        ip="$spec"
        ports=""
    fi

    echo "$ip|$ports"
}

# Function to add iptables rule with optional port restriction
# Wrapper for backward compatibility - now uses OS abstraction
add_iptables_rule() {
    add_firewall_rule "$@"
}

# Function to setup network restrictions
setup_network_restrictions() {
    local mode="$1"
    local user_uid
    user_uid=$(get_user_uid "$cfg_user")

    if [ "$mode" = "disabled" ]; then
        echo "Network restrictions: None. You're flyin' without that extra safety net."
        return 0
    fi

    # Check if chain already exists
    local chain_exists=false
    if firewall_chain_exists "$iptables_chain"; then
        chain_exists=true
        echo "Addin' network restrictions to existing chain (shared in single-user mode)..."

        # Remove the final catch-all rule (could be ACCEPT or REJECT depending on previous mode)
        # We need to remove it so we can add new rules, then re-add it at the end
        # Try to get the last rule number and delete it (Linux only)
        local last_rule_num=$(get_last_firewall_rule_number "$iptables_chain")
        if [ -n "$last_rule_num" ]; then
            echo "Removin' final rule (line $last_rule_num) to add new restrictions..."
            delete_firewall_rule_by_number "$iptables_chain" "$last_rule_num"
        fi
    else
        echo "Settin' up network restrictions (mode: $mode)..."
        # Create custom chain for claude-cage rules
        create_firewall_chain "$iptables_chain" "$user_uid" || {
            echo "Hold on. Couldn't create firewall chain. Network restrictions may not work right."
            return 1
        }
    fi

    if [ "$mode" = "allowlist" ]; then
        # No need to remove final rule here - already done above if chain exists

        # Allow user-configured domains
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Allow user-configured IPs
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
            done
        fi

        # Allow user-configured networks
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$network" "$ports"
            done
        fi

        # Reject everything else (re-add at the end)
        add_catchall_firewall_rule "$iptables_chain" "REJECT"

    elif [ "$mode" = "blocklist" ]; then
        # No need to remove final rule here - already done above if chain exists

        # First, allow exceptions (these rules are processed first)
        # Use INSERT mode so exceptions go at the beginning of the chain, before any existing blocks
        # Allow user-configured domains
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports" "insert"
                done < <(resolve_domain "$domain")
            done
        fi

        # Allow user-configured IPs
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports" "insert"
            done
        fi

        # Allow user-configured networks
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$network" "$ports" "insert"
            done
        fi

        # Then, block configured targets
        # Block user-configured domains
        if [ -n "$cfg_blockDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_blockDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "REJECT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Block user-configured IPs
        if [ -n "$cfg_blockIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_blockIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "REJECT" "$ip" "$ports"
            done
        fi

        # Block user-configured networks
        if [ -n "$cfg_blockNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_blockNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "REJECT" "$network" "$ports"
            done
        fi

        # Accept everything else
        add_catchall_firewall_rule "$iptables_chain" "ACCEPT"
    fi

    echo "Network restrictions in place. Locked down tight."
}

# Check for excluded files in sync directory (skip in directMount mode)
# Only check patterns that changed since last run
if [ "$cfg_directMount" != "workspace" ] && [ "$cfg_directMount" != "project" ] && [ -d "$cfg_sync" ]; then
    config_cache=".caged/${cfg_project}/excludes-cache"
    current_excludes="${cfg_excludePath}|${cfg_excludeName}|${cfg_excludeRegex}|${cfg_belowPath}"

    # Check if exclude patterns changed since last run
    if [ -f "$config_cache" ]; then
        previous_excludes=$(cat "$config_cache")
        if [ "$current_excludes" != "$previous_excludes" ]; then
            echo "Hold on now. Your exclude patterns changed since last time."
            echo "Let me check if any newly-excluded files are sittin' in the sync directory..."

            # Find newly added patterns by comparing
            excluded_files=()

            # Only check patterns that are new (weren't in previous config)
            # This is a simplified check - we scan all current excludes and warn the user

            # Check excludePath patterns
            if [ -n "$cfg_excludePath" ]; then
                IFS='|' read -ra paths <<< "$cfg_excludePath"
                for pattern in "${paths[@]}"; do
                    if [ -e "$cfg_sync/$pattern" ]; then
                        excluded_files+=("$cfg_sync/$pattern")
                    fi
                done
            fi

            # Check excludeName patterns
            if [ -n "$cfg_excludeName" ]; then
                IFS='|' read -ra names <<< "$cfg_excludeName"
                for pattern in "${names[@]}"; do
                    while IFS= read -r -d '' file; do
                        excluded_files+=("$file")
                    done < <(find "$cfg_sync" -name "$pattern" -print0 2>/dev/null)
                done
            fi

            # Check excludeRegex patterns
            if [ -n "$cfg_excludeRegex" ]; then
                IFS='|' read -ra regexes <<< "$cfg_excludeRegex"
                for pattern in "${regexes[@]}"; do
                    while IFS= read -r -d '' file; do
                        excluded_files+=("$file")
                    done < <(find "$cfg_sync" -regextype posix-extended -regex "$cfg_sync/$pattern" -print0 2>/dev/null)
                done
            fi

            # Check belowPath patterns
            if [ -n "$cfg_belowPath" ]; then
                IFS='|' read -ra paths <<< "$cfg_belowPath"
                for pattern in "${paths[@]}"; do
                    if [ -d "$cfg_sync/$pattern" ]; then
                        excluded_files+=("$cfg_sync/$pattern")
                    fi
                done
            fi

            # If excluded files found, prompt user
            if [ ${#excluded_files[@]} -gt 0 ]; then
                echo ""
                echo "Now hold on. We got files here that match your new exclusion rules:"
                for file in "${excluded_files[@]}"; do
                    echo "  - $file"
                done
                echo ""
                echo "These could be from before you changed the rules."
                echo "They'll be ignored during sync, but they're still takin' up space."
                echo ""
                read -p "Want me to remove these files? [y/N] " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    for file in "${excluded_files[@]}"; do
                        rm -rf "$file"
                        echo "Gone: $file"
                    done
                else
                    echo "Alright. They'll stay there but won't sync. Your call."
                fi
            fi
        fi
    fi

    # Save current exclude patterns for next run
    echo "$current_excludes" > "$config_cache"
fi

# Check if there's already a running instance
skip_setup=false
if [ -f "$pid_file" ]; then
    echo "Hold on now. Found a PID file from a previous run."
    echo "Checkin' if those processes are still alive..."

    running_pids=()
    while IFS= read -r pid; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            running_pids+=("$pid")
        fi
    done < "$pid_file"

    if [ ${#running_pids[@]} -gt 0 ]; then
        echo "Processes still runnin': ${running_pids[*]}"
        echo "Reusing existing unison and bindfs processes."
        echo ""
        skip_setup=true
    else
        echo "Those processes are gone. Cleanin' up the old PID file..."
        rm -f "$pid_file"
    fi
fi

if [ "$skip_setup" = false ]; then
    # Setup network restrictions if configured
    setup_network_restrictions "$cfg_networkMode"

    # Create mount point if it doesn't exist
    mkdir -p "$mount_point"

    # Create .caged/project-name/ directory for instance/PID files
    mkdir -p ".caged/$cfg_project"

    # In sync mode, create sync directory and set ownership
    if [ "$cfg_directMount" != "workspace" ] && [ "$cfg_directMount" != "project" ]; then
        mkdir -p "$cfg_sync"
    fi

    # Set ownership of .caged directory and everything under it to original user
    chown -R "$original_user:$original_user" ".caged"

    # Check if mount point is already mounted
    if mountpoint -q "$mount_point" 2>/dev/null; then
        if [ "$cfg_directMount" = "workspace" ]; then
            # In workspace mode, reusing an existing mount is fine
            # Just register this instance and continue
            echo "Mount point already exists at $mount_point. Reusin' it."
            echo "$instance_id" >> "$mount_instance_file"
            skip_mount=true
        elif [ "$cfg_directMount" = "project" ]; then
            # In project mode, mount point collision means another project is there
            echo "Hold on now. That mount point's already in use."
            echo "Location: $mount_point"
            echo ""
            echo "Another project's already mounted there."
            echo "Either that project's still runnin', or cleanup didn't happen."
            echo ""
            echo "Try one of these:"
            echo "  1. Run: sudo claude-cage --cleanup (if old instance is dead)"
            echo "  2. Check what's mounted: mount | grep $mount_point"
            exit 1
        else
            # In sync mode, an existing mount is a problem
            echo "Hold on now. That mount point's already in use."
            echo "Location: $mount_point"
            echo ""
            echo "Looks like another project's already mounted there."
            echo "Either that project's still runnin', or cleanup didn't happen."
            echo ""
            echo "Try one of these:"
            echo "  1. Set a different 'mounted' name in your config"
            echo "  2. Run: sudo claude-cage --cleanup (if old instance is dead)"
            echo "  3. Check what's mounted: mount | grep $mount_point"
            exit 1
        fi
    else
        skip_mount=false
    fi

    if [ "$cfg_directMount" = "workspace" ]; then
        if [ "$skip_mount" = "false" ]; then
            # Workspace mode: mount entire source directory
            echo "Workspace mode: mountin' $cfg_source directly..."
            # Quote paths properly to handle spaces
            if ! bindfs -u "$cfg_user" -g "$cfg_user" --create-for-user="$original_user" --create-for-group="$original_user" "./$cfg_source" "$mount_point"; then
                echo "Now we got a problem. bindfs failed to mount."
                echo "Check that bindfs is installed and $cfg_source exists."
                exit 1
            fi

            # Verify mount succeeded
            if ! mountpoint -q "$mount_point" 2>/dev/null; then
                echo "Somethin' went wrong. Mount point ain't there after bindfs."
                echo "Check your permissions and try again."
                exit 1
            fi

            echo "Mount successful."

            # Register this instance with the mount point tracker
            echo "$instance_id" >> "$mount_instance_file"
        fi
        # Note: if skip_mount=true, instance was already registered earlier
    elif [ "$cfg_directMount" = "project" ]; then
        # Project mode: mount only the specific project subdirectory
        echo "Project mode: mountin' $cfg_source/$start_subdir directly..."
        # Quote paths properly to handle spaces
        if ! bindfs -u "$cfg_user" -g "$cfg_user" --create-for-user="$original_user" --create-for-group="$original_user" "./$cfg_source/$start_subdir" "$mount_point"; then
            echo "Now we got a problem. bindfs failed to mount."
            echo "Check that bindfs is installed and $cfg_source/$start_subdir exists."
            exit 1
        fi

        # Verify mount succeeded
        if ! mountpoint -q "$mount_point" 2>/dev/null; then
            echo "Somethin' went wrong. Mount point ain't there after bindfs."
            echo "Check your permissions and try again."
            exit 1
        fi

        echo "Mount successful."
    else
        # Sync mode: use unison + bindfs
        # Build unison command with exclude options
        # Quote paths to handle spaces properly
        unison_cmd_base="unison \"./$cfg_source\" \"./$cfg_sync\" -batch -confirmbigdel=false"
        if [ -n "$cfg_exclude" ]; then
            unison_cmd_base="$unison_cmd_base $cfg_exclude"
        fi

        # Initial sync: force from source to sync to establish clean starting state
        unison_cmd_initial="$unison_cmd_base -force \"./$cfg_source\" -prefer \"./$cfg_source\""

        # Ongoing sync: bidirectional with auto-resolution
        unison_cmd_ongoing="$unison_cmd_base -auto"

        # Check if unison-fsmonitor is available for watch mode
        if command -v unison-fsmonitor >/dev/null 2>&1; then
            repeat_mode="watch"
        else
            # Fall back to polling mode (every 1 second)
            repeat_mode="1"
            echo "Looks like unison-fsmonitor ain't installed. That's alright."
            echo "We're gonna use polling mode instead. Check for changes every second."
            echo "You want it faster? Install unison-fsmonitor. But this'll do the job."
        fi

        # Run initial sync, then ongoing sync as the original user
        # Pass command to bash to preserve quoting
        su "$original_user" -c "bash -c '$unison_cmd_initial'" >/dev/null 2>&1
        su "$original_user" -c "bash -c '$unison_cmd_ongoing -repeat $repeat_mode'" >/dev/null 2>&1 &
        unison_pid=$!

        if ! bindfs -u "$cfg_user" -g "$cfg_user" --create-for-user="$original_user" --create-for-group="$original_user" "./$cfg_sync" "$mount_point"; then
            echo "Now we got a problem. bindfs failed to mount."
            echo "Check that bindfs is installed and $cfg_sync exists."
            # Kill unison since we're bailing
            kill "$unison_pid" 2>/dev/null
            exit 1
        fi

        # Verify mount succeeded
        if ! mountpoint -q "$mount_point" 2>/dev/null; then
            echo "Somethin' went wrong. Mount point ain't there after bindfs."
            echo "Check your permissions and try again."
            kill "$unison_pid" 2>/dev/null
            exit 1
        fi

        # Write unison PID to file for cleanup (bindfs doesn't run as a daemon)
        echo "$unison_pid" > "$pid_file"
    fi
else
    # Verify mount point still exists
    if ! mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Wait a minute. The mount point ain't there anymore."
        echo "Somethin' went wrong. Run: sudo claude-cage --cleanup"
        exit 1
    fi
    echo "Mount point's still there at $mount_point. We're good."
fi

# Register this instance
echo "$instance_id" >> "$local_instance_file"

# In single-user mode, also register globally
if [ -n "$global_instance_file" ]; then
    echo "$instance_id" >> "$global_instance_file"
fi

if [ "$test_mode" = true ]; then
    echo ""
    echo "=== TEST MODE ==="
    echo "Alright, everything's ready. Switchin' you over to user '$cfg_user' so you can test things out."
    if [ "$cfg_directMount" = "workspace" ]; then
        echo "Your files are mounted at: $mount_point"
        echo "Startin' you in subdirectory: $start_subdir"
        echo "You can access sibling projects from the mount root."
    elif [ "$cfg_directMount" = "project" ]; then
        echo "Your files are mounted at: $mount_point"
        echo "Only this project is accessible (no sibling projects)."
    else
        echo "Your files are mounted at: $mount_point"
    fi
    echo "When you're done pokin' around, type 'exit' and we'll clean up."
    echo "================="
    echo ""
    su - "$cfg_user"
    exit_code=$?
else
    # Build claude command with optional flags
    claude_cmd="claude"
    if [ "$claude_continue" = true ]; then
        claude_cmd="claude --continue"
    elif [ "$claude_resume" = true ]; then
        claude_cmd="claude --resume"
    fi

    # Run Claude as the caged user in the mounted directory
    if [ "$cfg_directMount" = "workspace" ]; then
        # Workspace mode: start in the specified subdirectory within the mount
        su - "$cfg_user" -c "cd \"$mount_point/$start_subdir\" && $claude_cmd"
    elif [ "$cfg_directMount" = "project" ]; then
        # Project mode: start at the mount point root (which is the project dir)
        su - "$cfg_user" -c "cd \"$mount_point\" && $claude_cmd"
    else
        # Sync mode: start in the mount point root
        su - "$cfg_user" -c "cd \"$mount_point\" && $claude_cmd"
    fi
    exit_code=$?
fi

# Explicit exit to ensure cleanup trap fires
exit $exit_code
