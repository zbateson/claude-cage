#!/bin/bash

# Important things first
print_banner() {
    local banner=$(cat << 'EOF'



   ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
  ██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
  ██║     ██║     ███████║██║   ██║██║  ██║█████╗
  ██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝
  ╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
   ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝
                  ___________
                .'           '.
               /  -_-    -_-   \
              |    (_)  (_)     |
              |                 |          ,----.
              |      .---.      |         /||||||\
               \    '.__.'     /         | ||||||.|
                '.          .'           | |||||| |
                  '-._____.-'            | |||||| |
                      |||                |_||||||_|
                     /|||\                 \    /
                    / ||| \                 |  |

        ██████╗ █████╗  ██████╗ ███████╗
        ██╔════╝██╔══██╗██╔════╝ ██╔════╝
        ██║     ███████║██║  ███╗█████╗
        ██║     ██╔══██║██║   ██║██╔══╝
        ╚██████╗██║  ██║╚██████╔╝███████╗
         ╚═════╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝


EOF
)

    # Print banner line by line with a slight delay for "slide up" effect
    while IFS= read -r line; do
        echo "$line"
        sleep 0.01
    done <<< "$banner"
    sleep 0.3
}

# Check if lua is available early (before sudo check)
if ! command -v lua >/dev/null 2>&1; then
    echo "Now listen carefully. We got a problem here."
    echo "I need lua installed on this bird."
    echo "Can't do nothin' without it."
    exit 1
fi

# Check if inotifywait is available (required for unison watch mode)
if ! command -v inotifywait >/dev/null 2>&1; then
    echo "Hold on now. We got a problem here."
    echo "Unison needs inotify-tools for file monitoring."
    echo "Without it, this bird ain't gonna watch your files properly."
    exit 1
fi

# Get the original user (in case running with sudo)
original_user="${SUDO_USER:-$USER}"

# Define config file paths
system_config="/etc/claude-cage/config"
user_config="/home/${original_user}/.config/claude-cage/config"
local_config="claude-cage.config"

# Local config is required
if [ ! -f "$local_config" ]; then
    echo "Hold on now. I'm lookin' for a file called '$local_config' and it ain't here."
    echo "Can't take off without that config file in this directory."
    echo "You understand what I'm tellin' you?"
    exit 1
fi

# Extract config values using Lua with multi-level loading
lua_output=$(lua <<EOF 2>&1
-- Function to merge two tables (later overrides earlier)
local function merge_config(base, override)
    local result = {}

    -- Copy base config
    for k, v in pairs(base) do
        result[k] = v
    end

    -- Override with new values
    for k, v in pairs(override) do
        local array_fields = {"excludeName", "excludePath", "excludeRegex", "belowPath", "allowedDomains", "allowedIPs", "allowedNetworks", "blockDomains", "blockIPs", "blockNetworks"}
        local is_array_field = false
        for _, field in ipairs(array_fields) do
            if k == field then
                is_array_field = true
                break
            end
        end

        if is_array_field and type(v) == "table" then
            -- Merge array fields
            result[k] = result[k] or {}
            for _, item in ipairs(v) do
                table.insert(result[k], item)
            end
        else
            -- Override value
            result[k] = v
        end
    end

    return result
end

-- Define a handler for claude_cage function
local configs = {}
function claude_cage(tbl)
    table.insert(configs, tbl)
end

-- Load configs in priority order (system -> user -> local)
local config_files = {
    "$system_config",
    "$user_config",
    "$local_config"
}

for _, path in ipairs(config_files) do
    local f = io.open(path, "r")
    if f then
        f:close()
        local success, err = pcall(function()
            dofile(path)
        end)
        if not success then
            io.stderr:write("Error loading config file: " .. path .. "\n")
            io.stderr:write(tostring(err) .. "\n")
            os.exit(1)
        end
    end
end

-- Merge all configs
local config = {}
for _, cfg in ipairs(configs) do
    config = merge_config(config, cfg)
end

-- Set defaults
local project = config.project or ""
local user = config.user or "claude"
local userMode = config.userMode or "single"  -- Options: "single" or "per-project"
local userAppend = config.userAppend or ""
local source = config.source or ""
local sync = config.sync or ""
local syncPrepend = config.syncPrepend or "claude-"
local mounted = config.mounted or ""
local showBanner = config.showBanner
if showBanner == nil then showBanner = true end

-- If project is set and source is not, use project for source
if project ~= "" and source == "" then
    source = project
end

-- Determine username based on userMode
if userMode == "single" then
    -- Single-user mode: use base username only
    -- userAppend is ignored
elseif userMode == "per-project" then
    -- Per-project mode: append identifier to username
    if userAppend ~= "" then
        -- Use explicitly set userAppend
        user = user .. "-" .. userAppend
    elseif project ~= "" then
        -- Use project name as default
        user = user .. "-" .. project
    else
        -- No userAppend and no project: use base username (fallback to single-user)
    end
else
    error("Invalid userMode: must be 'single' or 'per-project'")
end

-- If sync is empty, determine from project or source
if sync == "" then
    if project ~= "" then
        sync = syncPrepend .. project
    elseif source ~= "" then
        sync = syncPrepend .. source
    end
end

-- If mounted is empty, use "claude" as default
if mounted == "" then
    mounted = "claude"
end

-- Network configuration defaults
local networkMode = config.networkMode or "disabled"

-- Build exclude arguments for unison
local exclude_args = ""

-- excludeName: Ignore files/folders by name anywhere in the tree
if config.excludeName then
    for _, item in ipairs(config.excludeName) do
        exclude_args = exclude_args .. '-ignore "Name ' .. item .. '" '
    end
end

-- excludePath: Ignore exact paths relative to replica root
if config.excludePath then
    for _, item in ipairs(config.excludePath) do
        exclude_args = exclude_args .. '-ignore "Path ' .. item .. '" '
    end
end

-- excludeRegex: Ignore paths matching regex patterns
if config.excludeRegex then
    for _, item in ipairs(config.excludeRegex) do
        exclude_args = exclude_args .. '-ignore "Regex ' .. item .. '" '
    end
end

-- belowPath: Ignore everything below a certain path
if config.belowPath then
    for _, item in ipairs(config.belowPath) do
        exclude_args = exclude_args .. '-ignore "BelowPath ' .. item .. '" '
    end
end

-- Output basic config (use | delimiter to preserve empty fields)
print(user .. "|" .. source .. "|" .. sync .. "|" .. syncPrepend .. "|" .. mounted .. "|" .. exclude_args .. "|" .. tostring(showBanner))

-- Output exclude patterns for validation (pipe-separated)
local function array_to_string(arr)
    if not arr or #arr == 0 then return "EMPTY" end
    local result = {}
    for _, item in ipairs(arr) do
        table.insert(result, item)
    end
    return table.concat(result, "|")
end

print(array_to_string(config.excludePath))
print(array_to_string(config.excludeName))
print(array_to_string(config.excludeRegex))
print(array_to_string(config.belowPath))

-- Output network configuration
print(networkMode)
print(array_to_string(config.allowedDomains))
print(array_to_string(config.allowedIPs))
print(array_to_string(config.allowedNetworks))
print(array_to_string(config.blockDomains))
print(array_to_string(config.blockIPs))
print(array_to_string(config.blockNetworks))

-- Output project for validation
print(project)
EOF
)
lua_exit_code=$?

# Check if lua command failed BEFORE parsing output
if [ $lua_exit_code -ne 0 ]; then
    echo ""
    echo "============================================"
    echo "Somethin' went wrong with the config files"
    echo "============================================"
    echo ""
    echo "$lua_output"
    echo ""
    echo "Now I want you to fix that and we'll try this again."
    exit 1
fi

# Parse the lua output (only if lua succeeded)
{
    IFS='|' read -r cfg_user cfg_source cfg_sync cfg_syncPrepend cfg_mounted cfg_exclude cfg_showBanner
    read -r cfg_excludePath
    read -r cfg_excludeName
    read -r cfg_excludeRegex
    read -r cfg_belowPath
    read -r cfg_networkMode
    read -r cfg_allowedDomains
    read -r cfg_allowedIPs
    read -r cfg_allowedNetworks
    read -r cfg_blockDomains
    read -r cfg_blockIPs
    read -r cfg_blockNetworks
    read -r cfg_project
} <<< "$lua_output"

# Replace EMPTY placeholder with empty string for array values
[ "$cfg_excludePath" = "EMPTY" ] && cfg_excludePath=""
[ "$cfg_excludeName" = "EMPTY" ] && cfg_excludeName=""
[ "$cfg_excludeRegex" = "EMPTY" ] && cfg_excludeRegex=""
[ "$cfg_belowPath" = "EMPTY" ] && cfg_belowPath=""
[ "$cfg_allowedDomains" = "EMPTY" ] && cfg_allowedDomains=""
[ "$cfg_allowedIPs" = "EMPTY" ] && cfg_allowedIPs=""
[ "$cfg_allowedNetworks" = "EMPTY" ] && cfg_allowedNetworks=""
[ "$cfg_blockDomains" = "EMPTY" ] && cfg_blockDomains=""
[ "$cfg_blockIPs" = "EMPTY" ] && cfg_blockIPs=""
[ "$cfg_blockNetworks" = "EMPTY" ] && cfg_blockNetworks=""

# Parse command line arguments
test_mode=false
cleanup_mode=false
source_arg=""

for arg in "$@"; do
    if [ "$arg" = "--test" ]; then
        test_mode=true
    elif [ "$arg" = "--no-banner" ]; then
        cfg_showBanner="false"
    elif [ "$arg" = "--cleanup" ]; then
        cleanup_mode=true
    else
        source_arg="$arg"
    fi
done

# Allow source to be provided as command-line argument
if [ -n "$source_arg" ]; then
    cfg_source="$source_arg"
fi

# Validate required config
if [ -z "$cfg_project" ]; then
    echo "Listen to me very carefully now."
    echo "You need to put a 'project' in that ./claude-cage.config file."
    echo "Somethin' like: project = \"myproject\""
    echo "Can't proceed without it."
    exit 1
fi

if [ -z "$cfg_source" ]; then
    echo "Hold on. Where's the source directory?"
    echo "I need that specified in the config or on the command line."
    exit 1
fi

if [ ! -d "$cfg_source" ]; then
    echo "Now we got a problem. That source directory '$cfg_source' don't exist."
    echo "Can't work with somethin' that ain't there."
    exit 1
fi

# Handle cleanup mode
if [ "$cleanup_mode" = true ]; then
    # Now check for root
    if [ "$EUID" -ne 0 ]; then
        echo "Gonna need you to run this as root. Use sudo."
        exit 1
    fi

    echo "=== CLEANUP MODE ==="
    echo "Alright, let's clean up this operation."
    echo ""

    # Find and unmount any bindfs mounts for this user
    mount_point="/home/$cfg_user/$cfg_mounted"
    if mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Found mounted directory at $mount_point, unmountin' it now..."
        umount -l "$mount_point" 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "  Unmounted successfully."
        else
            echo "  Warning: Had trouble unmountin'. May need manual cleanup."
        fi
    else
        echo "No mounted directory found at $mount_point"
    fi

    # Clean up iptables rules for this user
    if id -u "$cfg_user" >/dev/null 2>&1; then
        user_uid=$(id -u "$cfg_user")
        # Look for any chains with our pattern
        for chain in $(iptables -L -n | grep "CLAUDE_CAGE_" | awk '{print $1}' | sort -u); do
            echo "Found iptables chain: $chain, cleanin' it up..."
            iptables -D OUTPUT -j "$chain" 2>/dev/null
            iptables -F "$chain" 2>/dev/null
            iptables -X "$chain" 2>/dev/null
            echo "  Cleaned up $chain"
        done
    fi

    # Kill processes from PID file
    if [ -f "$pid_file" ]; then
        echo "Found PID file, stoppin' tracked processes..."
        while IFS= read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
                echo "  Stopped process $pid"
            fi
        done < "$pid_file"
        rm -f "$pid_file"
        echo "  PID file removed."
    else
        echo "No PID file found at $pid_file"
    fi

    # Ask about user deletion
    if id -u "$cfg_user" >/dev/null 2>&1; then
        echo ""
        echo "User '$cfg_user' exists on this system."
        read -p "Delete user '$cfg_user'? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Alright, removin' user '$cfg_user'..."
            userdel -r "$cfg_user" 2>/dev/null || userdel "$cfg_user" 2>/dev/null
            if [ $? -eq 0 ]; then
                echo "  User removed."
            else
                echo "  Warning: Had trouble removin' the user. May need manual cleanup."
            fi
        else
            echo "Leavin' user '$cfg_user' as is."
        fi
    else
        echo "User '$cfg_user' doesn't exist. Nothin' to delete."
    fi

    echo ""
    echo "Cleanup complete. All done."
    exit 0
fi

# Now check for root after validating config
if [ "$EUID" -ne 0 ]; then
    echo "Gonna need you to run this as root. Use sudo."
    exit 1
fi

if [ "$cfg_showBanner" = "true" ]; then
    print_banner
fi

echo "Alright. Here's what we're workin' with:"
echo ""
echo "Configuration:"
echo "  Project:       $cfg_project"
echo "  User:          $cfg_user"
echo "  Source:        $cfg_source"
echo "  Sync:          $cfg_sync"
echo "  Mount point:   /home/$cfg_user/$cfg_mounted"
echo "  Network mode:  $cfg_networkMode"
echo ""
echo "Excludes:"
if [ -n "$cfg_excludePath" ]; then
    IFS='|' read -ra paths <<< "$cfg_excludePath"
    for path in "${paths[@]}"; do
        echo "  Path:          $path"
    done
fi
if [ -n "$cfg_excludeName" ]; then
    IFS='|' read -ra names <<< "$cfg_excludeName"
    for name in "${names[@]}"; do
        echo "  Name:          $name"
    done
fi
if [ -n "$cfg_excludeRegex" ]; then
    IFS='|' read -ra regexes <<< "$cfg_excludeRegex"
    for regex in "${regexes[@]}"; do
        echo "  Regex:         $regex"
    done
fi
if [ -n "$cfg_belowPath" ]; then
    IFS='|' read -ra belows <<< "$cfg_belowPath"
    for below in "${belows[@]}"; do
        echo "  Below path:    $below"
    done
fi
if [ -z "$cfg_excludePath$cfg_excludeName$cfg_excludeRegex$cfg_belowPath" ]; then
    echo "  (none)"
fi
echo ""

# Show active network restrictions if configured
if [ "$cfg_networkMode" != "disabled" ]; then
    echo "Network restrictions ($cfg_networkMode mode):"

    if [ "$cfg_networkMode" = "allowlist" ]; then
        echo "  Allow list (everything else blocked):"
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain in "${domains[@]}"; do
                echo "    Domain:  $domain"
            done
        fi
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip in "${ips[@]}"; do
                echo "    IP:      $ip"
            done
        fi
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network in "${networks[@]}"; do
                echo "    Network: $network"
            done
        fi
    elif [ "$cfg_networkMode" = "blocklist" ]; then
        echo "  Block list (everything else allowed):"
        if [ -n "$cfg_blockDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_blockDomains"
            for domain in "${domains[@]}"; do
                echo "    Domain:  $domain"
            done
        fi
        if [ -n "$cfg_blockIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_blockIPs"
            for ip in "${ips[@]}"; do
                echo "    IP:      $ip"
            done
        fi
        if [ -n "$cfg_blockNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_blockNetworks"
            for network in "${networks[@]}"; do
                echo "    Network: $network"
            done
        fi

        # Show exceptions if any exist
        if [ -n "$cfg_allowedDomains" ] || [ -n "$cfg_allowedIPs" ] || [ -n "$cfg_allowedNetworks" ]; then
            echo "  Exceptions (allowed even when blocked):"
            if [ -n "$cfg_allowedDomains" ]; then
                IFS='|' read -ra domains <<< "$cfg_allowedDomains"
                for domain in "${domains[@]}"; do
                    echo "    Domain:  $domain"
                done
            fi
            if [ -n "$cfg_allowedIPs" ]; then
                IFS='|' read -ra ips <<< "$cfg_allowedIPs"
                for ip in "${ips[@]}"; do
                    echo "    IP:      $ip"
                done
            fi
            if [ -n "$cfg_allowedNetworks" ]; then
                IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
                for network in "${networks[@]}"; do
                    echo "    Network: $network"
                done
            fi
        fi
    fi
    echo ""
fi

# Set computed values
cfg_user="${cfg_user:-claude}"
if [ -z "$cfg_sync" ]; then
    cfg_syncPrepend="${cfg_syncPrepend:-claude-}"
    cfg_sync="${cfg_syncPrepend}${cfg_source}"
fi
if [ -z "$cfg_mounted" ]; then
    cfg_mounted="$cfg_source"
fi

# Validate and sanitize username
original_username="$cfg_user"
sanitized_username="$cfg_user"
was_truncated=false

# Check for invalid characters (allowed: lowercase letters, digits, hyphens, underscores)
# Must start with a letter or underscore
if [[ ! "$sanitized_username" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]]; then
    # Replace invalid characters with hyphens
    # First, ensure it starts with a valid character
    if [[ ! "$sanitized_username" =~ ^[a-zA-Z_] ]]; then
        sanitized_username="u-$sanitized_username"
    fi
    # Replace invalid characters with hyphens
    sanitized_username=$(echo "$sanitized_username" | sed 's/[^a-zA-Z0-9_-]/-/g')
    # Convert to lowercase for maximum compatibility
    sanitized_username=$(echo "$sanitized_username" | tr '[:upper:]' '[:lower:]')
fi

# Remove trailing hyphens/underscores (valid but not best practice)
if [[ "$sanitized_username" =~ [-_]+$ ]]; then
    sanitized_username=$(echo "$sanitized_username" | sed 's/[-_]*$//')
fi

# Check username length (useradd has 32 character limit)
if [ ${#sanitized_username} -gt 32 ]; then
    sanitized_username="${sanitized_username:0:32}"
    # Re-check for trailing hyphens after truncation
    sanitized_username=$(echo "$sanitized_username" | sed 's/[-_]*$//')
    was_truncated=true
fi

# Display warning only if username was truncated
if [ "$was_truncated" = true ]; then
    echo ""
    echo "Hold on now. That username's too long for this bird."
    echo "What you wanted:  $original_username (${#original_username} characters)"
    echo "What you got:     $sanitized_username (${#sanitized_username} characters)"
    echo "Had to trim it down. Regulations, you understand."
    echo ""
fi

cfg_user="$sanitized_username"

# Track if user exists before we start
user_existed_before=false
if id -u "$cfg_user" >/dev/null 2>&1; then
    user_existed_before=true
fi

# Create claude-cage base directory for tracking/config
cage_home_base="/home/.claude-cage"
mkdir -p "$cage_home_base"

# Track whether we prompted the user to continue
user_was_prompted=false

# Create user if it doesn't exist
if ! id -u "$cfg_user" >/dev/null 2>&1; then
    echo "That user '$cfg_user' ain't on this system yet."
    read -p "Want me to create that user? [y/N] " -n 1 -r
    echo
    user_was_prompted=true
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # In single-user mode, use default home directory location
        # In multi-project mode, use /home/claude-cage/<user>
        if [[ "$cfg_user" == *"-"* ]]; then
            # Multi-project mode: home under /home/claude-cage
            user_home="$cage_home_base/$cfg_user"
            adduser --disabled-password --shell /bin/bash --home "$user_home" --comment "" "$cfg_user"
            echo "Done. User '$cfg_user' is ready to go (home: $user_home)."
        else
            # Single-user mode: default home directory
            adduser --disabled-password --shell /bin/bash --comment "" "$cfg_user"
            user_home=$(eval echo ~"$cfg_user")
            echo "Done. User '$cfg_user' is ready to go (home: $user_home)."
        fi
        echo "This user's temporary. Gone when we're done here."
    else
        echo "Can't fly this bird without that user. We're done here."
        exit 1
    fi
fi

# Prompt to continue if user wasn't already prompted during user creation
if [ "$user_was_prompted" = "false" ]; then
    echo ""
    read -p "Ready to proceed? [Y/n] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Nn]$ ]]; then
        echo "Alright, abortin' the mission."
        exit 0
    fi
fi

# Set user_home for later use
user_home=$(eval echo ~"$cfg_user")
mount_point="$user_home/${cfg_mounted}"

# Track iptables chain name for cleanup
# In single-user mode, use a shared chain name; otherwise use per-process chain
if [[ "$cfg_user" == *"-"* ]]; then
    # Multi-project mode: per-process chain
    iptables_chain="CLAUDE_CAGE_$$"
else
    # Single-user mode: shared chain for the user
    iptables_chain="CLAUDE_CAGE_${cfg_user}"
fi

# PID file to track running processes
pid_file="claude-cage.pid"

# Instance tracking file (tracks multiple instances)
instance_file="claude-cage.instances"

# This instance's ID
instance_id="$$"

cleanup() {
    echo ""
    echo "Alright, shuttin' down operations..."

    # Remove this instance from the instance file
    if [ -f "$instance_file" ]; then
        sed -i "/^$instance_id$/d" "$instance_file"

        # Check if there are other instances still running
        remaining_instances=()
        while IFS= read -r inst_id; do
            if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                remaining_instances+=("$inst_id")
            fi
        done < "$instance_file"

        if [ ${#remaining_instances[@]} -gt 0 ]; then
            echo "Other instances still runnin' (${remaining_instances[*]}). Leavin' processes alone."
            # Update instance file to remove dead instances
            printf "%s\n" "${remaining_instances[@]}" > "$instance_file"
            echo "This session's done. Stay safe out there."
            return
        else
            # No more instances, remove the instance file
            rm -f "$instance_file"
        fi
    fi

    # Only run full cleanup if this is the last instance
    echo "Last instance shuttin' down. Cleanin' up everything..."

    # Kill processes from PID file
    if [ -f "$pid_file" ]; then
        echo "Stoppin' processes from $pid_file..."
        while IFS= read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
            fi
        done < "$pid_file"
        rm -f "$pid_file"
    fi

    # Unmount the bindfs mount
    if mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Unmountin' $mount_point..."
        umount -l "$mount_point" 2>/dev/null
    fi

    # Clean up iptables rules
    if [[ "$cfg_user" == *"-"* ]]; then
        # Multi-project mode: always clean up per-process chain
        if iptables -L "$iptables_chain" >/dev/null 2>&1; then
            echo "Cleanin' up network restrictions..."
            iptables -D OUTPUT -j "$iptables_chain" 2>/dev/null
            iptables -F "$iptables_chain" 2>/dev/null
            iptables -X "$iptables_chain" 2>/dev/null
        fi
    else
        # Single-user mode: only clean up if no other instances exist
        # Check for any claude-cage.instances files under /home/.claude-cage
        cage_instances=$(find /home/.claude-cage -name "claude-cage.instances" -type f 2>/dev/null | wc -l)

        if [ "$cage_instances" -eq 0 ] && iptables -L "$iptables_chain" >/dev/null 2>&1; then
            echo "Last instance for user $cfg_user, cleanin' up network restrictions..."
            iptables -D OUTPUT -j "$iptables_chain" 2>/dev/null
            iptables -F "$iptables_chain" 2>/dev/null
            iptables -X "$iptables_chain" 2>/dev/null
        fi
    fi

    # Delete user if it didn't exist before
    if [ "$user_existed_before" = "false" ]; then
        if id -u "$cfg_user" >/dev/null 2>&1; then
            echo "User '$cfg_user' is temporary, removin' it now..."
            userdel -r "$cfg_user" 2>/dev/null || userdel "$cfg_user" 2>/dev/null
        fi
    fi

    echo "All done. Stay safe out there."
}
trap cleanup SIGINT SIGTERM EXIT

# Function to resolve domain to IPs
resolve_domain() {
    local domain="$1"
    # Use getent to resolve domain (supports /etc/hosts and DNS)
    getent ahosts "$domain" 2>/dev/null | awk '{print $1}' | sort -u
}

# Function to parse IP/domain:port specification
# Returns: ip, ports (comma-separated)
parse_ip_port() {
    local spec="$1"
    local ip=""
    local ports=""

    if [[ "$spec" =~ ^(.+):([0-9,]+)$ ]]; then
        ip="${BASH_REMATCH[1]}"
        ports="${BASH_REMATCH[2]}"
    else
        ip="$spec"
        ports=""
    fi

    echo "$ip|$ports"
}

# Function to add iptables rule with optional port restriction
add_iptables_rule() {
    local chain="$1"
    local action="$2"  # ACCEPT or REJECT
    local ip="$3"
    local ports="$4"   # Empty or comma-separated ports

    if [ -z "$ports" ]; then
        # No port restriction - allow/block all ports
        iptables -A "$chain" -d "$ip" -j "$action"
    else
        # Port restriction - apply to TCP and UDP
        if [[ "$ports" == *","* ]]; then
            # Multiple ports - use multiport
            iptables -A "$chain" -p tcp -d "$ip" -m multiport --dports "$ports" -j "$action"
            iptables -A "$chain" -p udp -d "$ip" -m multiport --dports "$ports" -j "$action"
        else
            # Single port
            iptables -A "$chain" -p tcp -d "$ip" --dport "$ports" -j "$action"
            iptables -A "$chain" -p udp -d "$ip" --dport "$ports" -j "$action"
        fi
    fi
}

# Function to setup network restrictions
setup_network_restrictions() {
    local mode="$1"
    local user_uid
    user_uid=$(id -u "$cfg_user")

    if [ "$mode" = "disabled" ]; then
        echo "Network isolation: disabled"
        return 0
    fi

    # Check if chain already exists
    local chain_exists=false
    if iptables -L "$iptables_chain" >/dev/null 2>&1; then
        chain_exists=true
        echo "Adding network restrictions to existing chain (shared in single-user mode)..."
    else
        echo "Setting up network restrictions (mode: $mode)..."
        # Create custom chain for claude-cage rules
        iptables -N "$iptables_chain" 2>/dev/null || {
            echo "Warning: Could not create iptables chain. Network restrictions may not work."
            return 1
        }
        # Jump to our chain for output from cfg_user
        iptables -I OUTPUT -m owner --uid-owner "$user_uid" -j "$iptables_chain"
    fi

    if [ "$mode" = "allowlist" ]; then
        # If chain exists, remove the final REJECT rule so we can add more ACCEPT rules
        if [ "$chain_exists" = true ]; then
            iptables -D "$iptables_chain" -j REJECT 2>/dev/null
        fi

        # Allow user-configured domains
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Allow user-configured IPs
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
            done
        fi

        # Allow user-configured networks
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$network" "$ports"
            done
        fi

        # Reject everything else (re-add at the end)
        iptables -A "$iptables_chain" -j REJECT

    elif [ "$mode" = "blocklist" ]; then
        # First, allow exceptions (these rules are processed first)
        # Allow user-configured domains
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Allow user-configured IPs
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
            done
        fi

        # Allow user-configured networks
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$network" "$ports"
            done
        fi

        # Then, block configured targets
        # Block user-configured domains
        if [ -n "$cfg_blockDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_blockDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "REJECT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Block user-configured IPs
        if [ -n "$cfg_blockIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_blockIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "REJECT" "$ip" "$ports"
            done
        fi

        # Block user-configured networks
        if [ -n "$cfg_blockNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_blockNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "REJECT" "$network" "$ports"
            done
        fi

        # Accept everything else
        iptables -A "$iptables_chain" -j ACCEPT
    fi

    echo "Network restrictions applied successfully"
}

# Check for excluded files in sync directory
if [ -d "$cfg_sync" ]; then
    echo "Doin' a quick sweep of the sync directory..."
    excluded_files=()

    # Check excludePath patterns
    if [ -n "$cfg_excludePath" ]; then
        IFS='|' read -ra paths <<< "$cfg_excludePath"
        for pattern in "${paths[@]}"; do
            if [ -e "$cfg_sync/$pattern" ]; then
                excluded_files+=("$cfg_sync/$pattern")
            fi
        done
    fi

    # Check excludeName patterns
    if [ -n "$cfg_excludeName" ]; then
        IFS='|' read -ra names <<< "$cfg_excludeName"
        for pattern in "${names[@]}"; do
            while IFS= read -r -d '' file; do
                excluded_files+=("$file")
            done < <(find "$cfg_sync" -name "$pattern" -print0 2>/dev/null)
        done
    fi

    # Check excludeRegex patterns
    if [ -n "$cfg_excludeRegex" ]; then
        IFS='|' read -ra regexes <<< "$cfg_excludeRegex"
        for pattern in "${regexes[@]}"; do
            while IFS= read -r -d '' file; do
                excluded_files+=("$file")
            done < <(find "$cfg_sync" -regextype posix-extended -regex "$cfg_sync/$pattern" -print0 2>/dev/null)
        done
    fi

    # Check belowPath patterns
    if [ -n "$cfg_belowPath" ]; then
        IFS='|' read -ra paths <<< "$cfg_belowPath"
        for pattern in "${paths[@]}"; do
            if [ -d "$cfg_sync/$pattern" ]; then
                excluded_files+=("$cfg_sync/$pattern")
            fi
        done
    fi

    # If excluded files found, prompt user
    if [ ${#excluded_files[@]} -gt 0 ]; then
        echo ""
        echo "Now hold on. We got files here that shouldn't be on this bird:"
        for file in "${excluded_files[@]}"; do
            echo "  - $file"
        done
        echo ""
        echo "Looks like they was from a previous flight with different rules."
        echo "Gonna need to clean 'em out before we take off."
        echo ""
        read -p "Want me to remove these files? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            for file in "${excluded_files[@]}"; do
                rm -rf "$file"
                echo "Gone: $file"
            done
        else
            echo "Alright, you handle it yourself. Can't proceed 'til they're gone."
            exit 1
        fi
    fi
fi

# Check if there's already a running instance
skip_setup=false
if [ -f "$pid_file" ]; then
    echo "Hold on now. Found a PID file from a previous run."
    echo "Checkin' if those processes are still alive..."

    running_pids=()
    while IFS= read -r pid; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            running_pids+=("$pid")
        fi
    done < "$pid_file"

    if [ ${#running_pids[@]} -gt 0 ]; then
        echo "Processes still runnin': ${running_pids[*]}"
        echo "Reusing existing unison and bindfs processes."
        echo ""
        skip_setup=true
    else
        echo "Those processes are gone. Cleanin' up the old PID file..."
        rm -f "$pid_file"
    fi
fi

if [ "$skip_setup" = false ]; then
    # Setup network restrictions if configured
    setup_network_restrictions "$cfg_networkMode"

    # Build unison command with exclude options
    unison_cmd="unison ./$cfg_source ./$cfg_sync -force ./$cfg_source -prefer ./$cfg_source -batch -confirmbigdel=false"
    if [ -n "$cfg_exclude" ]; then
        unison_cmd="$unison_cmd $cfg_exclude"
    fi

    # Run unison as the original user
    su -c "$unison_cmd" "$original_user" >/dev/null 2>&1
    su -c "$unison_cmd -repeat watch" "$original_user" >/dev/null 2>&1 &
    unison_pid=$!

    # Create mount point if it doesn't exist
    mkdir -p "$mount_point"

    bindfs -u "$cfg_user" -g "$cfg_user" --create-for-user="$original_user" --create-for-group="$original_user" "./$cfg_sync" "$mount_point"
    bindfs_pid=$!

    # Write PIDs to file for cleanup
    {
        echo "$unison_pid"
        echo "$bindfs_pid"
    } > "$pid_file"
else
    # Verify mount point still exists
    if ! mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Wait a minute. The mount point ain't there anymore."
        echo "Somethin' went wrong. Run: sudo claude-cage --cleanup"
        exit 1
    fi
    echo "Mount point verified at $mount_point"
fi

# Register this instance
echo "$instance_id" >> "$instance_file"

if [ "$test_mode" = true ]; then
    echo ""
    echo "=== TEST MODE ==="
    echo "Alright, everything's ready. Switchin' over to user '$cfg_user' for testin'."
    echo "Your files are mounted at: ~/$cfg_mounted"
    echo "Just 'cd $cfg_mounted' to get to 'em."
    echo "When you're done, type 'exit' and we'll clean up."
    echo "================="
    echo ""
    su - "$cfg_user"
    exit_code=$?
else
    # Run Claude as the original user, but in the mounted directory
    # This preserves authentication while still working with isolated files
    su - "$original_user" -c "cd $mount_point && claude"
    exit_code=$?
fi

# Explicit exit to ensure cleanup trap fires
exit $exit_code
