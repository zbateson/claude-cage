#!/bin/bash

# Important things first
print_banner() {
    local banner=$(cat << 'EOF'



   ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
  ██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
  ██║     ██║     ███████║██║   ██║██║  ██║█████╗
  ██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝
  ╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
   ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝
                  ___________
                .'           '.
               /  -_-    -_-   \
              |    (_)  (_)     |
              |                 |          ,----.
              |      .---.      |         /||||||\
               \    '.__.'     /         | ||||||.|
                '.          .'           | |||||| |
                  '-._____.-'            | |||||| |
                      |||                |_||||||_|
                     /|||\                 \    /
                    / ||| \                 |  |

        ██████╗ █████╗  ██████╗ ███████╗
        ██╔════╝██╔══██╗██╔════╝ ██╔════╝
        ██║     ███████║██║  ███╗█████╗
        ██║     ██╔══██║██║   ██║██╔══╝
        ╚██████╗██║  ██║╚██████╔╝███████╗
         ╚═════╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝


EOF
)

    # ANSI color codes
    local yellow='\033[33m'
    local reset='\033[0m'

    # Print banner line by line with a slight delay for "slide up" effect
    local line_num=0
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        # Lines 4-9 are CLAUDE (after 3 blank lines), lines 23-28 are CAGE
        if (( line_num >= 4 && line_num <= 9 )) || (( line_num >= 23 && line_num <= 28 )); then
            echo -e "${yellow}${line}${reset}"
        else
            echo "$line"
        fi
        sleep 0.01
    done <<< "$banner"
    sleep 0.3
}

# Check if lua is available early (before sudo check)
if ! command -v lua >/dev/null 2>&1; then
    echo "Now listen carefully. We got a problem here."
    echo "I need lua installed on this bird."
    echo "Can't do nothin' without it."
    exit 1
fi

# Check if inotifywait is available (required for unison watch mode)
if ! command -v inotifywait >/dev/null 2>&1; then
    echo "Hold on now. We got a problem here."
    echo "Unison needs inotify-tools for file monitoring."
    echo "Without it, this bird ain't gonna watch your files properly."
    exit 1
fi

# Get the original user (in case running with sudo)
original_user="${SUDO_USER:-$USER}"

# Define config file paths
system_config="/etc/claude-cage/config"
user_config="/home/${original_user}/.config/claude-cage/config"
local_config="claude-cage.config"

# Local config is required
if [ ! -f "$local_config" ]; then
    echo "Hold on now. I'm lookin' for a file called '$local_config' and it ain't here."
    echo "Can't take off without that config file in this directory."
    echo "You understand what I'm tellin' you?"
    exit 1
fi

# Extract config values using Lua with multi-level loading
lua_output=$(lua <<EOF 2>&1
-- Function to merge two tables (later overrides earlier)
local function merge_config(base, override)
    local result = {}

    -- Copy base config
    for k, v in pairs(base) do
        result[k] = v
    end

    -- Override with new values
    for k, v in pairs(override) do
        local array_fields = {"excludeName", "excludePath", "excludeRegex", "belowPath", "allowedDomains", "allowedIPs", "allowedNetworks", "blockDomains", "blockIPs", "blockNetworks"}
        local is_array_field = false
        for _, field in ipairs(array_fields) do
            if k == field then
                is_array_field = true
                break
            end
        end

        if is_array_field and type(v) == "table" then
            -- Merge array fields
            result[k] = result[k] or {}
            for _, item in ipairs(v) do
                table.insert(result[k], item)
            end
        else
            -- Override value
            result[k] = v
        end
    end

    return result
end

-- Define a handler for claude_cage function
local configs = {}
function claude_cage(tbl)
    table.insert(configs, tbl)
end

-- Load configs in priority order (system -> user -> local)
local config_files = {
    "$system_config",
    "$user_config",
    "$local_config"
}

for _, path in ipairs(config_files) do
    local f = io.open(path, "r")
    if f then
        f:close()
        local success, err = pcall(function()
            dofile(path)
        end)
        if not success then
            io.stderr:write("Error loading config file: " .. path .. "\n")
            io.stderr:write(tostring(err) .. "\n")
            os.exit(1)
        end
    end
end

-- Merge all configs
local config = {}
for _, cfg in ipairs(configs) do
    config = merge_config(config, cfg)
end

-- Set defaults
local project = config.project or ""
local user = config.user or "claude"
local userMode = config.userMode or "single"  -- Options: "single" or "per-project"
local userAppend = config.userAppend or ""
local source = config.source or ""
local sync = config.sync or ""
local syncPrepend = config.syncPrepend or ".caged-"
local mountBase = config.mountBase or ""
local mounted = config.mounted or ""
local directMount = config.directMount or false
local showBanner = config.showBanner
if showBanner == nil then showBanner = true end

-- If project is set and source is not, use project for source (sync mode only)
-- In direct mount mode, source should default to "." (handled in bash)
if project ~= "" and source == "" and not directMount then
    source = project
end

-- Determine username based on userMode
if userMode == "single" then
    -- Single-user mode: use base username only
    -- userAppend is ignored
elseif userMode == "per-project" then
    -- Per-project mode: append identifier to username
    if userAppend ~= "" then
        -- Use explicitly set userAppend
        user = user .. "-" .. userAppend
    elseif project ~= "" then
        -- Use project name as default
        user = user .. "-" .. project
    else
        -- No userAppend and no project: use base username (fallback to single-user)
    end
else
    error("Invalid userMode: must be 'single' or 'per-project'")
end

-- If sync is empty, determine from project or source
if sync == "" then
    if project ~= "" then
        sync = syncPrepend .. project
    elseif source ~= "" then
        sync = syncPrepend .. source
    end
end

-- Set mountBase default
if mountBase == "" then
    mountBase = "caged"
end

-- Set mounted default to project name
if mounted == "" then
    if project ~= "" then
        mounted = project
    else
        mounted = "project"
    end
end

-- Network configuration defaults
local networkMode = config.networkMode or "disabled"

-- Build exclude arguments for unison
local exclude_args = ""

-- excludeName: Ignore files/folders by name anywhere in the tree
if config.excludeName then
    for _, item in ipairs(config.excludeName) do
        exclude_args = exclude_args .. '-ignore "Name ' .. item .. '" '
    end
end

-- excludePath: Ignore exact paths relative to replica root
if config.excludePath then
    for _, item in ipairs(config.excludePath) do
        exclude_args = exclude_args .. '-ignore "Path ' .. item .. '" '
    end
end

-- excludeRegex: Ignore paths matching regex patterns
if config.excludeRegex then
    for _, item in ipairs(config.excludeRegex) do
        exclude_args = exclude_args .. '-ignore "Regex ' .. item .. '" '
    end
end

-- belowPath: Ignore everything below a certain path
if config.belowPath then
    for _, item in ipairs(config.belowPath) do
        exclude_args = exclude_args .. '-ignore "BelowPath ' .. item .. '" '
    end
end

-- Output basic config (use | delimiter to preserve empty fields)
print(user .. "|" .. source .. "|" .. sync .. "|" .. syncPrepend .. "|" .. mountBase .. "|" .. mounted .. "|" .. exclude_args .. "|" .. tostring(showBanner))

-- Output exclude patterns for validation (pipe-separated)
local function array_to_string(arr)
    if not arr or #arr == 0 then return "EMPTY" end
    local result = {}
    for _, item in ipairs(arr) do
        table.insert(result, item)
    end
    return table.concat(result, "|")
end

print(array_to_string(config.excludePath))
print(array_to_string(config.excludeName))
print(array_to_string(config.excludeRegex))
print(array_to_string(config.belowPath))

-- Output network configuration
print(networkMode)
print(array_to_string(config.allowedDomains))
print(array_to_string(config.allowedIPs))
print(array_to_string(config.allowedNetworks))
print(array_to_string(config.blockDomains))
print(array_to_string(config.blockIPs))
print(array_to_string(config.blockNetworks))

-- Output project for validation
print(project)

-- Output directMount setting
print(tostring(directMount))
EOF
)
lua_exit_code=$?

# Check if lua command failed BEFORE parsing output
if [ $lua_exit_code -ne 0 ]; then
    echo ""
    echo "============================================"
    echo "Somethin' went wrong with the config files"
    echo "============================================"
    echo ""
    echo "$lua_output"
    echo ""
    echo "Now I want you to fix that and we'll try this again."
    exit 1
fi

# Parse the lua output (only if lua succeeded)
{
    IFS='|' read -r cfg_user cfg_source cfg_sync cfg_syncPrepend cfg_mountBase cfg_mounted cfg_exclude cfg_showBanner
    read -r cfg_excludePath
    read -r cfg_excludeName
    read -r cfg_excludeRegex
    read -r cfg_belowPath
    read -r cfg_networkMode
    read -r cfg_allowedDomains
    read -r cfg_allowedIPs
    read -r cfg_allowedNetworks
    read -r cfg_blockDomains
    read -r cfg_blockIPs
    read -r cfg_blockNetworks
    read -r cfg_project
    read -r cfg_directMount
} <<< "$lua_output"

# Replace EMPTY placeholder with empty string for array values
[ "$cfg_excludePath" = "EMPTY" ] && cfg_excludePath=""
[ "$cfg_excludeName" = "EMPTY" ] && cfg_excludeName=""
[ "$cfg_excludeRegex" = "EMPTY" ] && cfg_excludeRegex=""
[ "$cfg_belowPath" = "EMPTY" ] && cfg_belowPath=""
[ "$cfg_allowedDomains" = "EMPTY" ] && cfg_allowedDomains=""
[ "$cfg_allowedIPs" = "EMPTY" ] && cfg_allowedIPs=""
[ "$cfg_allowedNetworks" = "EMPTY" ] && cfg_allowedNetworks=""
[ "$cfg_blockDomains" = "EMPTY" ] && cfg_blockDomains=""
[ "$cfg_blockIPs" = "EMPTY" ] && cfg_blockIPs=""
[ "$cfg_blockNetworks" = "EMPTY" ] && cfg_blockNetworks=""

# Parse command line arguments
test_mode=false
cleanup_mode=false
source_arg=""
start_subdir=""

for arg in "$@"; do
    if [ "$arg" = "--test" ]; then
        test_mode=true
    elif [ "$arg" = "--no-banner" ]; then
        cfg_showBanner="false"
    elif [ "$arg" = "--cleanup" ]; then
        cleanup_mode=true
    else
        source_arg="$arg"
    fi
done

# Handle command-line argument based on mode
if [ -n "$source_arg" ]; then
    if [ "$cfg_directMount" = "true" ]; then
        # In directMount mode, argument is the subdirectory to start in
        start_subdir="$source_arg"
    else
        # In sync mode, command-line arguments are not supported
        echo "Hold on now. You can't pass a directory argument in sync mode."
        echo "The source directory is set in the config file only."
        echo "If you want to specify a starting directory, use directMount mode."
        exit 1
    fi
fi

# In directMount mode, default source to current directory if not set
if [ "$cfg_directMount" = "true" ] && [ -z "$cfg_source" ]; then
    cfg_source="."
fi

# Validate required config
if [ -z "$cfg_project" ]; then
    echo "Listen to me very carefully now."
    echo "You need to put a 'project' in that ./claude-cage.config file."
    echo "Somethin' like: project = \"myproject\""
    echo "Can't proceed without it."
    exit 1
fi

if [ -z "$cfg_source" ]; then
    echo "Hold on. Where's the source directory?"
    echo "I need that specified in the config or on the command line."
    exit 1
fi

if [ ! -d "$cfg_source" ]; then
    echo "Now we got a problem. That source directory '$cfg_source' don't exist."
    echo "Can't work with somethin' that ain't there."
    exit 1
fi

# In directMount mode, require a starting subdirectory
if [ "$cfg_directMount" = "true" ]; then
    if [ -z "$start_subdir" ]; then
        echo "Hold on now. In direct mount mode, you gotta tell me which project to start in."
        echo "Run it like: sudo claude-cage <subdirectory>"
        echo "For example: sudo claude-cage my-project"
        exit 1
    fi

    # Validate the subdirectory exists
    if [ ! -d "$cfg_source/$start_subdir" ]; then
        echo "Now we got a problem. That subdirectory '$cfg_source/$start_subdir' don't exist."
        echo "Can't start Claude in somethin' that ain't there."
        exit 1
    fi
fi

# Handle cleanup mode
if [ "$cleanup_mode" = true ]; then
    # Now check for root
    if [ "$EUID" -ne 0 ]; then
        echo "Gonna need you to run this as root. Use sudo."
        exit 1
    fi

    echo "=== CLEANUP MODE ==="
    echo "Alright, let's clean up this operation."
    echo ""

    # Find and unmount any bindfs mounts for this user
    mount_point="/home/$cfg_user/$cfg_mounted"
    if mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Found mounted directory at $mount_point, unmountin' it now..."
        umount -l "$mount_point" 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "  Unmounted. All clear."
        else
            echo "  Had some trouble unmountin'. May need to clean that up yourself."
        fi
    else
        echo "No mounted directory at $mount_point. Already clean."
    fi

    # Clean up iptables rules for this user
    if id -u "$cfg_user" >/dev/null 2>&1; then
        user_uid=$(id -u "$cfg_user")
        # Look for any chains with our pattern
        for chain in $(iptables -L -n | grep "CLAUDE_CAGE_" | awk '{print $1}' | sort -u); do
            echo "Found iptables chain: $chain, cleanin' it up..."
            iptables -D OUTPUT -j "$chain" 2>/dev/null
            iptables -F "$chain" 2>/dev/null
            iptables -X "$chain" 2>/dev/null
            echo "  Done. $chain is gone."
        done
    fi

    # Kill processes from PID file
    if [ -f "$pid_file" ]; then
        echo "Found PID file, stoppin' tracked processes..."
        while IFS= read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
                echo "  Process $pid stopped."
            fi
        done < "$pid_file"
        rm -f "$pid_file"
        echo "  PID file's gone."
    else
        echo "No PID file found at $pid_file"
    fi

    # Ask about user deletion
    if id -u "$cfg_user" >/dev/null 2>&1; then
        echo ""
        echo "User '$cfg_user' exists on this system."
        read -p "Delete user '$cfg_user'? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Alright, removin' user '$cfg_user'..."
            userdel -r "$cfg_user" 2>/dev/null || userdel "$cfg_user" 2>/dev/null
            if [ $? -eq 0 ]; then
                echo "  Done. User's gone."
            else
                echo "  Had some trouble removin' the user. May need to clean that up yourself."
            fi
        else
            echo "Leavin' user '$cfg_user' as is."
        fi
    else
        echo "User '$cfg_user' doesn't exist. Nothin' to delete."
    fi

    echo ""
    echo "Cleanup complete. All done."
    exit 0
fi

# Now check for root after validating config
if [ "$EUID" -ne 0 ]; then
    echo "Gonna need you to run this as root. Use sudo."
    exit 1
fi

if [ "$cfg_showBanner" = "true" ]; then
    print_banner
fi

echo "Alright. Here's what we're workin' with:"
echo ""
echo "Configuration:"
echo "  Project:       $cfg_project"
echo "  User:          $cfg_user"
if [ "$cfg_directMount" = "true" ]; then
    echo "  Mode:          Direct mount (no sync)"
    if [ -n "$start_subdir" ]; then
        echo "  Start dir:     $start_subdir"
    fi
else
    echo "  Mode:          Sync mode"
    echo "  Source:        $cfg_source"
    echo "  Sync:          $cfg_sync"
fi
if [ -n "$cfg_mountBase" ]; then
    echo "  Mount point:   /home/$cfg_user/$cfg_mountBase/$cfg_mounted"
else
    echo "  Mount point:   /home/$cfg_user/$cfg_mounted"
fi
echo "  Network mode:  $cfg_networkMode"
echo ""
echo "Excludes:"
if [ -n "$cfg_excludePath" ]; then
    IFS='|' read -ra paths <<< "$cfg_excludePath"
    for path in "${paths[@]}"; do
        echo "  Path:          $path"
    done
fi
if [ -n "$cfg_excludeName" ]; then
    IFS='|' read -ra names <<< "$cfg_excludeName"
    for name in "${names[@]}"; do
        echo "  Name:          $name"
    done
fi
if [ -n "$cfg_excludeRegex" ]; then
    IFS='|' read -ra regexes <<< "$cfg_excludeRegex"
    for regex in "${regexes[@]}"; do
        echo "  Regex:         $regex"
    done
fi
if [ -n "$cfg_belowPath" ]; then
    IFS='|' read -ra belows <<< "$cfg_belowPath"
    for below in "${belows[@]}"; do
        echo "  Below path:    $below"
    done
fi
if [ -z "$cfg_excludePath$cfg_excludeName$cfg_excludeRegex$cfg_belowPath" ]; then
    echo "  (none)"
fi
echo ""

# Show active network restrictions if configured
if [ "$cfg_networkMode" != "disabled" ]; then
    echo "Network restrictions ($cfg_networkMode mode):"

    if [ "$cfg_networkMode" = "allowlist" ]; then
        echo "  Allow list (everything else blocked):"
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain in "${domains[@]}"; do
                echo "    Domain:  $domain"
            done
        fi
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip in "${ips[@]}"; do
                echo "    IP:      $ip"
            done
        fi
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network in "${networks[@]}"; do
                echo "    Network: $network"
            done
        fi
    elif [ "$cfg_networkMode" = "blocklist" ]; then
        echo "  Block list (everything else allowed):"
        if [ -n "$cfg_blockDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_blockDomains"
            for domain in "${domains[@]}"; do
                echo "    Domain:  $domain"
            done
        fi
        if [ -n "$cfg_blockIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_blockIPs"
            for ip in "${ips[@]}"; do
                echo "    IP:      $ip"
            done
        fi
        if [ -n "$cfg_blockNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_blockNetworks"
            for network in "${networks[@]}"; do
                echo "    Network: $network"
            done
        fi

        # Show exceptions if any exist
        if [ -n "$cfg_allowedDomains" ] || [ -n "$cfg_allowedIPs" ] || [ -n "$cfg_allowedNetworks" ]; then
            echo "  Exceptions (allowed even when blocked):"
            if [ -n "$cfg_allowedDomains" ]; then
                IFS='|' read -ra domains <<< "$cfg_allowedDomains"
                for domain in "${domains[@]}"; do
                    echo "    Domain:  $domain"
                done
            fi
            if [ -n "$cfg_allowedIPs" ]; then
                IFS='|' read -ra ips <<< "$cfg_allowedIPs"
                for ip in "${ips[@]}"; do
                    echo "    IP:      $ip"
                done
            fi
            if [ -n "$cfg_allowedNetworks" ]; then
                IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
                for network in "${networks[@]}"; do
                    echo "    Network: $network"
                done
            fi
        fi
    fi
    echo ""
fi

# Set computed values
cfg_user="${cfg_user:-claude}"
if [ -z "$cfg_sync" ]; then
    cfg_syncPrepend="${cfg_syncPrepend:-claude-}"
    cfg_sync="${cfg_syncPrepend}${cfg_source}"
fi
if [ -z "$cfg_mounted" ]; then
    cfg_mounted="$cfg_source"
fi

# Validate and sanitize username
original_username="$cfg_user"
sanitized_username="$cfg_user"
was_truncated=false

# Check for invalid characters (allowed: lowercase letters, digits, hyphens, underscores)
# Must start with a letter or underscore
if [[ ! "$sanitized_username" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]]; then
    # Replace invalid characters with hyphens
    # First, ensure it starts with a valid character
    if [[ ! "$sanitized_username" =~ ^[a-zA-Z_] ]]; then
        sanitized_username="u-$sanitized_username"
    fi
    # Replace invalid characters with hyphens
    sanitized_username=$(echo "$sanitized_username" | sed 's/[^a-zA-Z0-9_-]/-/g')
    # Convert to lowercase for maximum compatibility
    sanitized_username=$(echo "$sanitized_username" | tr '[:upper:]' '[:lower:]')
fi

# Remove trailing hyphens/underscores (valid but not best practice)
if [[ "$sanitized_username" =~ [-_]+$ ]]; then
    sanitized_username=$(echo "$sanitized_username" | sed 's/[-_]*$//')
fi

# Check username length (useradd has 32 character limit)
if [ ${#sanitized_username} -gt 32 ]; then
    sanitized_username="${sanitized_username:0:32}"
    # Re-check for trailing hyphens after truncation
    sanitized_username=$(echo "$sanitized_username" | sed 's/[-_]*$//')
    was_truncated=true
fi

# Display warning only if username was truncated
if [ "$was_truncated" = true ]; then
    echo ""
    echo "Hold on now. That username's too long for this bird."
    echo "What you wanted:  $original_username (${#original_username} characters)"
    echo "What you got:     $sanitized_username (${#sanitized_username} characters)"
    echo "Had to trim it down. Regulations, you understand."
    echo ""
fi

cfg_user="$sanitized_username"

# Track if user exists before we start
user_existed_before=false
if id -u "$cfg_user" >/dev/null 2>&1; then
    user_existed_before=true
fi

# Create claude-cage base directory for tracking/config
cage_home_base="/home/.claude-cage"
mkdir -p "$cage_home_base"

# Track whether we prompted the user to continue
user_was_prompted=false

# Create user if it doesn't exist
if ! id -u "$cfg_user" >/dev/null 2>&1; then
    echo "That user '$cfg_user' ain't on this system yet."
    read -p "Want me to create that user? [y/N] " -n 1 -r
    echo
    user_was_prompted=true
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # In single-user mode, use default home directory location
        # In multi-project mode, use /home/claude-cage/<user>
        if [[ "$cfg_user" == *"-"* ]]; then
            # Multi-project mode: home under /home/claude-cage
            user_home="$cage_home_base/$cfg_user"
            adduser --disabled-password --shell /bin/bash --home "$user_home" --comment "" "$cfg_user"
            echo "Done. User '$cfg_user' is ready to go (home: $user_home)."
        else
            # Single-user mode: default home directory
            adduser --disabled-password --shell /bin/bash --comment "" "$cfg_user"
            user_home=$(eval echo ~"$cfg_user")
            echo "Done. User '$cfg_user' is ready to go (home: $user_home)."
        fi
        echo "This user's temporary. Gone when we're done here."
    else
        echo "Can't fly this bird without that user. We're done here."
        exit 1
    fi
fi

# Prompt to continue if user wasn't already prompted during user creation
if [ "$user_was_prompted" = "false" ]; then
    echo ""
    read -p "Ready to proceed? [Y/n] " -n 1 -r -s key
    echo
    if [[ "$key" == $'\e' ]] || [[ $key =~ ^[Nn]$ ]]; then
        echo "Alright, abortin' the mission."
        exit 0
    fi
fi

# Set user_home for later use
user_home=$(eval echo ~"$cfg_user")

# Construct mount point: /home/<user>/<mountBase>/<mounted>/ or /home/<user>/<mounted>/
if [ -n "$cfg_mountBase" ]; then
    mount_point="$user_home/${cfg_mountBase}/${cfg_mounted}"
else
    mount_point="$user_home/${cfg_mounted}"
fi

# Track iptables chain name for cleanup
# In single-user mode, use a shared chain name; otherwise use per-process chain
if [[ "$cfg_user" == *"-"* ]]; then
    # Multi-project mode: per-process chain
    iptables_chain="CLAUDE_CAGE_$$"
else
    # Single-user mode: shared chain for the user
    iptables_chain="CLAUDE_CAGE_${cfg_user}"
fi

# PID file to track running processes (local to this project directory)
pid_file="claude-cage.pid"

# Instance tracking files
# Local instance file (tracks instances of THIS project)
local_instance_file="claude-cage.instances"

# Global instance file (tracks all projects for this user in single-user mode)
if [[ "$cfg_user" == *"-"* ]]; then
    # Per-project mode: only use local instance file
    global_instance_file=""
else
    # Single-user mode: track instances globally in user's home
    global_instance_file="$user_home/.claude-cage-instances"
fi

# This instance's ID
instance_id="$$"

cleanup() {
    echo ""
    echo "Alright, shuttin' down operations..."

    # Remove this instance from the local instance file
    if [ -f "$local_instance_file" ]; then
        sed -i "/^$instance_id$/d" "$local_instance_file"

        # Check if there are other instances of THIS project still running
        remaining_local=()
        while IFS= read -r inst_id; do
            if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                remaining_local+=("$inst_id")
            fi
        done < "$local_instance_file"

        if [ ${#remaining_local[@]} -gt 0 ]; then
            echo "Other instances of this project still runnin' (${remaining_local[*]}). Leavin' processes alone."
            # Update local instance file to remove dead instances
            printf "%s\n" "${remaining_local[@]}" > "$local_instance_file"

            # Still need to remove from global in single-user mode
            if [ -n "$global_instance_file" ] && [ -f "$global_instance_file" ]; then
                sed -i "/^$instance_id$/d" "$global_instance_file"
            fi

            echo "This session's done. Stay safe out there."
            return
        else
            # No more instances of this project, remove the local instance file
            rm -f "$local_instance_file"
        fi
    fi

    # Remove from global instance file (single-user mode)
    if [ -n "$global_instance_file" ] && [ -f "$global_instance_file" ]; then
        sed -i "/^$instance_id$/d" "$global_instance_file"

        # Check if there are other projects still running as this user
        remaining_global=()
        while IFS= read -r inst_id; do
            if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                remaining_global+=("$inst_id")
            fi
        done < "$global_instance_file" 2>/dev/null

        if [ ${#remaining_global[@]} -gt 0 ]; then
            echo "Other projects still runnin' as user $cfg_user (${remaining_global[*]})."
            echo "Cleanin' up this project only. User and network rules stay in place."
            # Update global instance file to remove dead instances
            printf "%s\n" "${remaining_global[@]}" > "$global_instance_file"

            # Clean up local processes and mount
            if [ -f "$pid_file" ]; then
                echo "Stoppin' processes from $pid_file..."
                while IFS= read -r pid; do
                    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                        kill "$pid" 2>/dev/null
                    fi
                done < "$pid_file"
                rm -f "$pid_file"
            fi

            if mountpoint -q "$mount_point" 2>/dev/null; then
                echo "Unmountin' $mount_point..."
                umount -l "$mount_point" 2>/dev/null
            fi

            echo "This project's done. Other projects still flyin'. Stay safe out there."
            return
        else
            # No more instances for this user, remove the global instance file
            rm -f "$global_instance_file"
        fi
    fi

    # Only run full cleanup if this is the last instance
    echo "Last instance shuttin' down. Cleanin' up everything..."

    # Kill processes from PID file
    if [ -f "$pid_file" ]; then
        echo "Stoppin' processes from $pid_file..."
        while IFS= read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null
            fi
        done < "$pid_file"
        rm -f "$pid_file"
    fi

    # Unmount the bindfs mount
    if mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Unmountin' $mount_point..."
        umount -l "$mount_point" 2>/dev/null
    fi

    # Clean up iptables rules
    if [[ "$cfg_user" == *"-"* ]]; then
        # Multi-project mode: always clean up per-process chain
        if iptables -L "$iptables_chain" >/dev/null 2>&1; then
            echo "Cleanin' up network restrictions..."
            iptables -D OUTPUT -j "$iptables_chain" 2>/dev/null
            iptables -F "$iptables_chain" 2>/dev/null
            iptables -X "$iptables_chain" 2>/dev/null
        fi
    else
        # Single-user mode: only clean up if no other instances exist
        # Check the global instance file
        has_other_instances=false
        if [ -n "$global_instance_file" ] && [ -f "$global_instance_file" ]; then
            # Check if there are any live instances in the global file
            while IFS= read -r inst_id; do
                if [ -n "$inst_id" ] && kill -0 "$inst_id" 2>/dev/null; then
                    has_other_instances=true
                    break
                fi
            done < "$global_instance_file"
        fi

        if [ "$has_other_instances" = "false" ] && iptables -L "$iptables_chain" >/dev/null 2>&1; then
            echo "Last instance for user $cfg_user, cleanin' up network restrictions..."
            iptables -D OUTPUT -j "$iptables_chain" 2>/dev/null
            iptables -F "$iptables_chain" 2>/dev/null
            iptables -X "$iptables_chain" 2>/dev/null
        fi
    fi

    # Delete user if it didn't exist before
    if [ "$user_existed_before" = "false" ]; then
        if id -u "$cfg_user" >/dev/null 2>&1; then
            echo "User '$cfg_user' is temporary, removin' it now..."
            userdel -r "$cfg_user" 2>/dev/null || userdel "$cfg_user" 2>/dev/null
        fi
    fi

    echo "All done. Stay safe out there."
}
trap cleanup SIGINT SIGTERM EXIT

# Function to resolve domain to IPs
resolve_domain() {
    local domain="$1"
    # Use getent to resolve domain (supports /etc/hosts and DNS)
    getent ahosts "$domain" 2>/dev/null | awk '{print $1}' | sort -u
}

# Function to parse IP/domain:port specification
# Returns: ip, ports (comma-separated)
parse_ip_port() {
    local spec="$1"
    local ip=""
    local ports=""

    if [[ "$spec" =~ ^(.+):([0-9,]+)$ ]]; then
        ip="${BASH_REMATCH[1]}"
        ports="${BASH_REMATCH[2]}"
    else
        ip="$spec"
        ports=""
    fi

    echo "$ip|$ports"
}

# Function to add iptables rule with optional port restriction
add_iptables_rule() {
    local chain="$1"
    local action="$2"  # ACCEPT or REJECT
    local ip="$3"
    local ports="$4"   # Empty or comma-separated ports
    local insert_mode="${5:-append}"  # "insert" or "append" (default: append)

    local iptables_cmd="iptables -A"
    if [ "$insert_mode" = "insert" ]; then
        iptables_cmd="iptables -I"
    fi

    if [ -z "$ports" ]; then
        # No port restriction - allow/block all ports
        $iptables_cmd "$chain" -d "$ip" -j "$action"
    else
        # Port restriction - apply to TCP and UDP
        if [[ "$ports" == *","* ]]; then
            # Multiple ports - use multiport
            $iptables_cmd "$chain" -p tcp -d "$ip" -m multiport --dports "$ports" -j "$action"
            $iptables_cmd "$chain" -p udp -d "$ip" -m multiport --dports "$ports" -j "$action"
        else
            # Single port
            $iptables_cmd "$chain" -p tcp -d "$ip" --dport "$ports" -j "$action"
            $iptables_cmd "$chain" -p udp -d "$ip" --dport "$ports" -j "$action"
        fi
    fi
}

# Function to setup network restrictions
setup_network_restrictions() {
    local mode="$1"
    local user_uid
    user_uid=$(id -u "$cfg_user")

    if [ "$mode" = "disabled" ]; then
        echo "Network restrictions: None. You're flyin' without that extra safety net."
        return 0
    fi

    # Check if chain already exists
    local chain_exists=false
    if iptables -L "$iptables_chain" >/dev/null 2>&1; then
        chain_exists=true
        echo "Addin' network restrictions to existing chain (shared in single-user mode)..."

        # Remove the final catch-all rule (could be ACCEPT or REJECT depending on previous mode)
        # We need to remove it so we can add new rules, then re-add it at the end
        # Try to get the last rule number and delete it
        local last_rule_num=$(iptables -L "$iptables_chain" -n --line-numbers | grep -E "^[0-9]" | tail -1 | awk '{print $1}')
        if [ -n "$last_rule_num" ]; then
            echo "Removin' final rule (line $last_rule_num) to add new restrictions..."
            iptables -D "$iptables_chain" "$last_rule_num" 2>/dev/null
        fi
    else
        echo "Settin' up network restrictions (mode: $mode)..."
        # Create custom chain for claude-cage rules
        iptables -N "$iptables_chain" 2>/dev/null || {
            echo "Hold on. Couldn't create iptables chain. Network restrictions may not work right."
            return 1
        }
        # Jump to our chain for output from cfg_user
        iptables -I OUTPUT -m owner --uid-owner "$user_uid" -j "$iptables_chain"
    fi

    if [ "$mode" = "allowlist" ]; then
        # No need to remove final rule here - already done above if chain exists

        # Allow user-configured domains
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Allow user-configured IPs
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports"
            done
        fi

        # Allow user-configured networks
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$network" "$ports"
            done
        fi

        # Reject everything else (re-add at the end)
        iptables -A "$iptables_chain" -j REJECT

    elif [ "$mode" = "blocklist" ]; then
        # No need to remove final rule here - already done above if chain exists

        # First, allow exceptions (these rules are processed first)
        # Use INSERT mode so exceptions go at the beginning of the chain, before any existing blocks
        # Allow user-configured domains
        if [ -n "$cfg_allowedDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_allowedDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports" "insert"
                done < <(resolve_domain "$domain")
            done
        fi

        # Allow user-configured IPs
        if [ -n "$cfg_allowedIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_allowedIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$ip" "$ports" "insert"
            done
        fi

        # Allow user-configured networks
        if [ -n "$cfg_allowedNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_allowedNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "ACCEPT" "$network" "$ports" "insert"
            done
        fi

        # Then, block configured targets
        # Block user-configured domains
        if [ -n "$cfg_blockDomains" ]; then
            IFS='|' read -ra domains <<< "$cfg_blockDomains"
            for domain_spec in "${domains[@]}"; do
                IFS='|' read -r domain ports < <(parse_ip_port "$domain_spec")
                while IFS= read -r ip; do
                    [ -n "$ip" ] && add_iptables_rule "$iptables_chain" "REJECT" "$ip" "$ports"
                done < <(resolve_domain "$domain")
            done
        fi

        # Block user-configured IPs
        if [ -n "$cfg_blockIPs" ]; then
            IFS='|' read -ra ips <<< "$cfg_blockIPs"
            for ip_spec in "${ips[@]}"; do
                IFS='|' read -r ip ports < <(parse_ip_port "$ip_spec")
                add_iptables_rule "$iptables_chain" "REJECT" "$ip" "$ports"
            done
        fi

        # Block user-configured networks
        if [ -n "$cfg_blockNetworks" ]; then
            IFS='|' read -ra networks <<< "$cfg_blockNetworks"
            for network_spec in "${networks[@]}"; do
                IFS='|' read -r network ports < <(parse_ip_port "$network_spec")
                add_iptables_rule "$iptables_chain" "REJECT" "$network" "$ports"
            done
        fi

        # Accept everything else
        iptables -A "$iptables_chain" -j ACCEPT
    fi

    echo "Network restrictions in place. Locked down tight."
}

# Check for excluded files in sync directory (skip in directMount mode)
# Only check patterns that changed since last run
if [ "$cfg_directMount" != "true" ] && [ -d "$cfg_sync" ]; then
    config_cache=".claude-cage-excludes.${cfg_project}"
    current_excludes="${cfg_excludePath}|${cfg_excludeName}|${cfg_excludeRegex}|${cfg_belowPath}"

    # Check if exclude patterns changed since last run
    if [ -f "$config_cache" ]; then
        previous_excludes=$(cat "$config_cache")
        if [ "$current_excludes" != "$previous_excludes" ]; then
            echo "Hold on now. Your exclude patterns changed since last time."
            echo "Let me check if any newly-excluded files are sittin' in the sync directory..."

            # Find newly added patterns by comparing
            excluded_files=()

            # Only check patterns that are new (weren't in previous config)
            # This is a simplified check - we scan all current excludes and warn the user

            # Check excludePath patterns
            if [ -n "$cfg_excludePath" ]; then
                IFS='|' read -ra paths <<< "$cfg_excludePath"
                for pattern in "${paths[@]}"; do
                    if [ -e "$cfg_sync/$pattern" ]; then
                        excluded_files+=("$cfg_sync/$pattern")
                    fi
                done
            fi

            # Check excludeName patterns
            if [ -n "$cfg_excludeName" ]; then
                IFS='|' read -ra names <<< "$cfg_excludeName"
                for pattern in "${names[@]}"; do
                    while IFS= read -r -d '' file; do
                        excluded_files+=("$file")
                    done < <(find "$cfg_sync" -name "$pattern" -print0 2>/dev/null)
                done
            fi

            # Check excludeRegex patterns
            if [ -n "$cfg_excludeRegex" ]; then
                IFS='|' read -ra regexes <<< "$cfg_excludeRegex"
                for pattern in "${regexes[@]}"; do
                    while IFS= read -r -d '' file; do
                        excluded_files+=("$file")
                    done < <(find "$cfg_sync" -regextype posix-extended -regex "$cfg_sync/$pattern" -print0 2>/dev/null)
                done
            fi

            # Check belowPath patterns
            if [ -n "$cfg_belowPath" ]; then
                IFS='|' read -ra paths <<< "$cfg_belowPath"
                for pattern in "${paths[@]}"; do
                    if [ -d "$cfg_sync/$pattern" ]; then
                        excluded_files+=("$cfg_sync/$pattern")
                    fi
                done
            fi

            # If excluded files found, prompt user
            if [ ${#excluded_files[@]} -gt 0 ]; then
                echo ""
                echo "Now hold on. We got files here that match your new exclusion rules:"
                for file in "${excluded_files[@]}"; do
                    echo "  - $file"
                done
                echo ""
                echo "These could be from before you changed the rules."
                echo "They'll be ignored during sync, but they're still takin' up space."
                echo ""
                read -p "Want me to remove these files? [y/N] " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    for file in "${excluded_files[@]}"; do
                        rm -rf "$file"
                        echo "Gone: $file"
                    done
                else
                    echo "Alright. They'll stay there but won't sync. Your call."
                fi
            fi
        fi
    fi

    # Save current exclude patterns for next run
    echo "$current_excludes" > "$config_cache"
fi

# Check if there's already a running instance
skip_setup=false
if [ -f "$pid_file" ]; then
    echo "Hold on now. Found a PID file from a previous run."
    echo "Checkin' if those processes are still alive..."

    running_pids=()
    while IFS= read -r pid; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            running_pids+=("$pid")
        fi
    done < "$pid_file"

    if [ ${#running_pids[@]} -gt 0 ]; then
        echo "Processes still runnin': ${running_pids[*]}"
        echo "Reusing existing unison and bindfs processes."
        echo ""
        skip_setup=true
    else
        echo "Those processes are gone. Cleanin' up the old PID file..."
        rm -f "$pid_file"
    fi
fi

if [ "$skip_setup" = false ]; then
    # Setup network restrictions if configured
    setup_network_restrictions "$cfg_networkMode"

    # Create mount point if it doesn't exist
    mkdir -p "$mount_point"

    # Check if mount point is already mounted (different project using same destination)
    if mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Hold on now. That mount point's already in use."
        echo "Location: $mount_point"
        echo ""
        echo "Looks like another project's already mounted there."
        echo "Either that project's still runnin', or cleanup didn't happen."
        echo ""
        echo "Try one of these:"
        echo "  1. Set a different 'mounted' name in your config"
        echo "  2. Run: sudo claude-cage --cleanup (if old instance is dead)"
        echo "  3. Check what's mounted: mount | grep $mount_point"
        exit 1
    fi

    if [ "$cfg_directMount" = "true" ]; then
        # Direct mount mode: skip unison, mount source directly
        echo "Direct mount mode: mountin' $cfg_source directly..."
        bindfs -u "$cfg_user" -g "$cfg_user" --create-for-user="$original_user" --create-for-group="$original_user" "./$cfg_source" "$mount_point"
        bindfs_pid=$!

        # Write only bindfs PID to file
        echo "$bindfs_pid" > "$pid_file"
    else
        # Sync mode: use unison + bindfs
        # Build unison command with exclude options
        unison_cmd_base="unison ./$cfg_source ./$cfg_sync -batch -confirmbigdel=false"
        if [ -n "$cfg_exclude" ]; then
            unison_cmd_base="$unison_cmd_base $cfg_exclude"
        fi

        # Initial sync: force from source to sync to establish clean starting state
        unison_cmd_initial="$unison_cmd_base -force ./$cfg_source -prefer ./$cfg_source"

        # Ongoing sync: bidirectional with auto-resolution
        unison_cmd_ongoing="$unison_cmd_base -auto"

        # Check if unison-fsmonitor is available for watch mode
        if command -v unison-fsmonitor >/dev/null 2>&1; then
            repeat_mode="watch"
        else
            # Fall back to polling mode (every 1 second)
            repeat_mode="1"
            echo "Looks like unison-fsmonitor ain't installed. That's alright."
            echo "We're gonna use polling mode instead. Check for changes every second."
            echo "You want it faster? Install unison-fsmonitor. But this'll do the job."
        fi

        # Run initial sync, then ongoing sync as the original user
        su -c "$unison_cmd_initial" "$original_user" >/dev/null 2>&1
        su -c "$unison_cmd_ongoing -repeat $repeat_mode" "$original_user" >/dev/null 2>&1 &
        unison_pid=$!

        bindfs -u "$cfg_user" -g "$cfg_user" --create-for-user="$original_user" --create-for-group="$original_user" "./$cfg_sync" "$mount_point"
        bindfs_pid=$!

        # Write PIDs to file for cleanup
        {
            echo "$unison_pid"
            echo "$bindfs_pid"
        } > "$pid_file"
    fi
else
    # Verify mount point still exists
    if ! mountpoint -q "$mount_point" 2>/dev/null; then
        echo "Wait a minute. The mount point ain't there anymore."
        echo "Somethin' went wrong. Run: sudo claude-cage --cleanup"
        exit 1
    fi
    echo "Mount point's still there at $mount_point. We're good."
fi

# Register this instance
echo "$instance_id" >> "$local_instance_file"

# In single-user mode, also register globally
if [ -n "$global_instance_file" ]; then
    echo "$instance_id" >> "$global_instance_file"
fi

if [ "$test_mode" = true ]; then
    echo ""
    echo "=== TEST MODE ==="
    echo "Alright, everything's ready. Switchin' you over to user '$cfg_user' so you can test things out."
    if [ "$cfg_directMount" = "true" ] && [ -n "$start_subdir" ]; then
        if [ -n "$cfg_mountBase" ]; then
            echo "Your files are mounted at: ~/$cfg_mountBase/$cfg_mounted"
        else
            echo "Your files are mounted at: ~/$cfg_mounted"
        fi
        echo "Startin' you in subdirectory: $start_subdir"
        echo "When you're done pokin' around, type 'exit' and we'll clean up."
    else
        if [ -n "$cfg_mountBase" ]; then
            echo "Your files are mounted at: ~/$cfg_mountBase/$cfg_mounted"
            echo "Just 'cd $cfg_mountBase/$cfg_mounted' to get to 'em."
        else
            echo "Your files are mounted at: ~/$cfg_mounted"
            echo "Just 'cd $cfg_mounted' to get to 'em."
        fi
        echo "When you're done pokin' around, type 'exit' and we'll clean up."
    fi
    echo "================="
    echo ""
    su - "$cfg_user"
    exit_code=$?
else
    # Run Claude as the caged user in the mounted directory
    if [ "$cfg_directMount" = "true" ] && [ -n "$start_subdir" ]; then
        # In directMount mode, start in the specified subdirectory
        su - "$cfg_user" -c "cd $mount_point/$start_subdir && claude"
    else
        # In sync mode, start in the mount point root
        su - "$cfg_user" -c "cd $mount_point && claude"
    fi
    exit_code=$?
fi

# Explicit exit to ensure cleanup trap fires
exit $exit_code
